<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="title: LeetCode &amp;amp; Data Structure &amp;amp; Algorithms date: 2019-11-19 12:50:43 tags: algorithm categories: computer science toc: true copyright: true mathjax: true Data structure and algorithms compl">
<meta property="og:type" content="article">
<meta property="og:title" content="datastructure-algorithm">
<meta property="og:url" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;index.html">
<meta property="og:site_name" content="BeNsoN">
<meta property="og:description" content="title: LeetCode &amp;amp; Data Structure &amp;amp; Algorithms date: 2019-11-19 12:50:43 tags: algorithm categories: computer science toc: true copyright: true mathjax: true Data structure and algorithms compl">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20191203164455493.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20191216213002168.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200101225159240.png">
<meta property="og:image" content="https:&#x2F;&#x2F;qph.fs.quoracdn.net&#x2F;main-qimg-81f0496575b8298c1365af1a2964128b">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200108155358169.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200108155347948.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200108155334928.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200121183006316.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200201153422750.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200201153631576.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200121164044574.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200121162945121.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215151542313.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215151549042.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215154256298.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200121215833534.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Insertion%20Sort.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Bubble%20Sort.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Selection%20Sort.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Merge%20Sort%202-8473215.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214200013055.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214200028634.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Quicksort.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214204542917.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214205046188.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214204721186.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214205007775.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Heapsort.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214211827086.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214211838349.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214211909214.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214212204273.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214213916677.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214213010292.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214213044981.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200214213100185.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216135431797.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216135405007.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216142110276.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200105235101400.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215195851066.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215185049028.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215220122368.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215220143020.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215233626966.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216002021695.png">
<meta property="og:image" content="file:&#x2F;&#x2F;&#x2F;Users&#x2F;huangbenson&#x2F;SteinsGate9.github.io&#x2F;source&#x2F;_posts&#x2F;datastructure-algorithm&#x2F;image-20200215233830446.png?lastModify=1581763828">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215233905979.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216003754336.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215234610956.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200216003909764.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215003158269.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215003312699.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215004538426.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215003440903.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200215003451614.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20191210210016705.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_4756.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_4560.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Untitled-22.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Untitled-28.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_3698.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_6261.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Untitled-18.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;Untitled-4-8376111.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20200107214608898.png">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_2222.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_3698-7375059.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_5430.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_3650.JPG">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;IMG_9352.JPG">
<meta property="og:updated_time" content="2020-02-16T06:35:07.385Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;12&#x2F;03&#x2F;datastructure-algorithm&#x2F;image-20191203164455493.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: 'FV65T83Q2V',
      apiKey: '5008cf0478de4ac53102baceee722a4d',
      indexName: 'steinsgate9',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://SteinsGate9.github.io/2019/12/03/datastructure-algorithm/"/>





  <title>datastructure-algorithm | BeNsoN</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<!--     <a href="https://github.com/SteinsGate9" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style> -->

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BeNsoN</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Live Long, Play Hard.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://SteinsGate9.github.io/2019/12/03/datastructure-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Benson">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/006y8mN6gy1g96p07mbexj30uf0u0npd.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BeNsoN">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">datastructure-algorithm</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T16:40:56+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">total read
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>times
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  22k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  124
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>title: LeetCode &amp; Data Structure &amp; Algorithms date: 2019-11-19 12:50:43 tags: algorithm categories: computer science toc: true copyright: true mathjax: true</p>
<p>Data structure and algorithms complexity analysis &amp; proofs &amp; leetcode problems.</p>
<a id="more"></a>
<h1 id="data-structures">1. data structures</h1>
<ul>
<li><p><strong>Note</strong>: Since most of STL will meet daily need, the following passage will describe basically self-implementation data structrues and analyze their complexities. We use <code>Structure</code> to describe it's intuition, <code>Usage</code> meaning how will it help with real problems, <code>Complexity</code> to analyze it's complexity.</p></li>
<li><p><strong>Note</strong>: overall picture of data structure</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20191203164455493.png"></p></li>
<li><p><strong>Note</strong>: datastructure complexity, set.find() is O(1)</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20191216213002168.png"></p></li>
<li><p><strong>Note</strong>: sorting algorithms</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200101225159240.png"></p></li>
<li><p><strong>Note</strong>: STL operations</p>
<figure>
<img src="https://qph.fs.quoracdn.net/main-qimg-81f0496575b8298c1365af1a2964128b" alt="img"><figcaption>img</figcaption>
</figure></li>
</ul>
<h2 id="linear-adt">1.1. linear ADT</h2>
<h3 id="vector">1.1.1. vector</h3>
<h3 id="map">1.1.2. map</h3>
<ul>
<li><strong>Usage</strong>:
<ul>
<li>to separate problem/ squeeze searching space(1178)</li>
<li>to find the next smallerst larger / next largest smaller</li>
</ul></li>
</ul>
<h3 id="stack">1.1.3. stack</h3>
<ul>
<li><p><strong>Usage</strong>: normally used for keeping a increasing(decreasing just opposite) sequence as well as partial maximum, normally concerned with greedy method</p>
<ul>
<li><p>Smallest element of [1:i]</p></li>
<li><p>Smallest (increasing) number of[1:i]</p></li>
<li><p>Next smallest larger element of ([i]) (decreasing stack)</p>
<ul>
<li><strong>Note</strong>: by sorting, and doing PNL on index stack.</li>
</ul></li>
<li><p>Previous nearest less element of ([i])</p>
<ul>
<li><strong>Note</strong>: each step do the following: 1) fixed ith outcome by poping those are larger 2) fixed possible solutions from [1:i] for i+1 and other elements. so keep an array of [possible previous less elements as well as already updated[1:i] ] it is a natually formed increasing array.</li>
</ul></li>
<li><p>Next nearest less element of ([i])</p>
<ul>
<li><strong>Note</strong>: each step do the following: 1)updated some from [1:i-1] outcome by poping those are larger 2) fixed unupdated indexes. The reason why we want to pop elements because 3-&gt;7-&gt;8-&gt;2 we can't reach 3 unless we pop, of course we can record all undecided indexes and move a pointer. And we can find out the problem naturally forms a increasing array (the undecided values), so stack can be used to store these values. It is important to point out that the problem itself forms an increasing array of [ undecided indexed [1:i]], stack is only a easy and natural way to implement it.</li>
</ul></li>
<li><p>parser</p>
<ul>
<li><strong>Note</strong> : make sure starting condition and jumping end condition and while recursive</li>
</ul></li>
</ul></li>
</ul>
<h3 id="heap">1.1.4. heap</h3>
<ul>
<li><p><strong>Usage</strong>: heap are great data structure for local max extracting which means greedy algorithms</p>
<ul>
<li>extract local min/max</li>
</ul></li>
</ul>
<h3 id="bitset">1.1.5. bitset</h3>
<ul>
<li><p><strong>Usage</strong>:</p>
<ul>
<li><p>异或的特性。第 136 题，第 268 题，第 389 题，第 421 题，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = x</span><br><span class="line">x ^ <span class="number">11111</span>……<span class="number">1111</span> = ~x</span><br><span class="line">x ^ (~x) = <span class="number">11111</span>……<span class="number">1111</span></span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line">a ^ b = c  =&gt; a ^ c = b  =&gt; b ^ c = a (交换律)</span><br><span class="line">a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律)</span><br></pre></td></tr></table></figure></li>
<li><p>构造特殊 Mask，将特殊位置放 0 或 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 将 x 最右边的 n 位清零， x &amp; ( ~<span class="number">0</span> &lt;&lt; n )</span><br><span class="line"><span class="number">2.</span> 获取 x 的第 n 位值(<span class="number">0</span> 或者 <span class="number">1</span>)，(x &gt;&gt; n) &amp; <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 获取 x 的第 n 位的幂值，x &amp; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>))</span><br><span class="line"><span class="number">4.</span> 仅将第 n 位置为 <span class="number">1</span>，x | (<span class="number">1</span> &lt;&lt; n)</span><br><span class="line"><span class="number">5.</span> 仅将第 n 位置为 <span class="number">0</span>，x &amp; (~(<span class="number">1</span> &lt;&lt; n))</span><br><span class="line"><span class="number">6.</span> 将 x 最高位至第 n 位(含)清零，x &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)</span><br><span class="line"><span class="number">7.</span> 将第 n 位至第 <span class="number">0</span> 位(含)清零，x &amp; (~((<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">1</span>)）</span><br></pre></td></tr></table></figure></li>
<li><p>有特殊意义的 &amp; 位操作运算。第 260 题，第 201 题，第 318 题，第 371 题，第 397 题，第 461 题，第 693 题，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X &amp; <span class="number">1</span> == <span class="number">1</span> 判断是否是奇数(偶数)</span><br><span class="line">X &amp; = (X - <span class="number">1</span>) 将最低位(LSB)的 <span class="number">1</span> 清零</span><br><span class="line">X &amp; -X 得到最低位(LSB)的 <span class="number">1</span></span><br><span class="line">X &amp; ~X = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="tree-adt">1.2. tree ADT</h2>
<h3 id="binary-tree">1.2.1. binary tree</h3>
<h4 id="binary-special-tree">1.2.1.1. binary special tree</h4>
<ul>
<li><p><strong>Intuition/Structure</strong>: Every node except the leaf nodes have two children.</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200108155358169.png"></p></li>
<li><p><strong>Intuition/Structure</strong>: Every level except the last level is completely filled and all the nodes are left justified.</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200108155347948.png"></p></li>
<li><p><strong>Intuition/Structure</strong>: Every node except the leaf nodes have two children and every level (last level too) is completely filled.</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200108155334928.png"></p></li>
</ul>
<h5 id="segment-tree">1.2.1.1.1. segment tree</h5>
<ul>
<li><p><strong>Usage</strong> : 线段树（segment tree），顾名思义， 是用来存放给定区间（segment, or interval）内对应信息的一种数据结构。与<a href="https://www.jianshu.com/p/5b209c029acd" target="_blank" rel="noopener">树状数组（binary indexed tree）</a>相似，线段树也用来处理数组相应的区间查询（range query）和元素更新（update）操作。</p>
<p><strong>Difference with BIT</strong>: 与树状数组不同的是，ST也可以进行区间最大值，区间最小值（Range Minimum/Maximum Query problem）或s者区间异或值的查询。</p></li>
<li><p><strong>Intuition/Structure</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200121183006316.png"></p>
<p>从数据结构的角度来说，线段树是用一个<strong>完全二叉树</strong>来存储对应于其每一个区间（segment）的数据。该二叉树的每一个结点中保存着相对应于这一个区间的信息。同时，线段树所使用的这个二叉树是用一个数组保存的，与堆（Heap）的实现方式相同。</p>
<p>e.g. 给定一个长度为<code>N</code>的数组<code>arr</code>，其所对应的线段树<code>T</code>各个结点的含义如下：</p>
<ol type="1">
<li><code>T</code>的根结点代表整个数组所在的区间对应的信息，及<code>arr[0:N)</code>（<strong>不含N</strong>)所对应的信息。</li>
<li><code>T</code>的每一个叶结点存储对应于输入数组的每一个单个元素构成的区间<code>arr[i]</code>所对应的信息，此处`0≤i。</li>
<li><code>T</code>的每一个中间结点存储对应于输入数组某一区间<code>arr[i:j]</code>对应的信息，此处`0≤i。</li>
</ol>
<p>以根结点为例，根结点代表<code>arr[0:N]</code>区间所对应的信息，接着根结点被分为两个子树，分别存储<code>arr[0:(N-1)/2]</code>及<code>arr[(N-1)/2+1:N]</code>两个子区间对应的信息。也就是说，对于每一个结点，其左右子结点分别存储母结点区间拆分为两半之后各自区间的信息。也就是说对于长度为<code>N</code>的输入数组，线段树的高度为<code>logN</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">segmentTree[<span class="number">1</span>] = arr[<span class="number">0</span>:<span class="number">8</span>)</span><br><span class="line">segmentTree[<span class="number">2</span>] = arr[<span class="number">0</span>:<span class="number">4</span>)</span><br><span class="line">segmentTree[<span class="number">3</span>] = arr[<span class="number">4</span>:<span class="number">8</span>)</span><br><span class="line">segmentTree[<span class="number">4</span>] = arr[<span class="number">0</span>:<span class="number">2</span>)</span><br><span class="line">segmentTree[<span class="number">5</span>] = arr[<span class="number">2</span>:<span class="number">4</span>)</span><br><span class="line">segmentTree[<span class="number">6</span>] = arr[<span class="number">4</span>:<span class="number">6</span>)</span><br><span class="line">segmentTree[<span class="number">7</span>] = arr[<span class="number">6</span>:<span class="number">8</span>)</span><br><span class="line">segmentTree[<span class="number">8</span>] = arr[<span class="number">0</span>]</span><br><span class="line">segmentTree[<span class="number">9</span>] = arr[<span class="number">1</span>]</span><br><span class="line">segmentTree[<span class="number">10</span>] = arr[<span class="number">2</span>]</span><br><span class="line">segmentTree[<span class="number">11</span>] = arr[<span class="number">3</span>]</span><br><span class="line">segmentTree[<span class="number">12</span>] = arr[<span class="number">4</span>]</span><br><span class="line">segmentTree[<span class="number">13</span>] = arr[<span class="number">5</span>]</span><br><span class="line">segmentTree[<span class="number">14</span>] = arr[<span class="number">6</span>]</span><br><span class="line">segmentTree[<span class="number">15</span>] = arr[<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: actually we can make sure that the last layer is even. (total is odd, 1+2+4 is odd, last is even), 这个是可以证明的，也就是每两个最后节点上面都是和节点，证明的结果是需要2n-1个array来存放，这个逻辑是从”能放下“出发的，证明出来要用多少个来放。</p></li>
<li><p><strong>Complexity</strong>:</p>
<ul>
<li><p>update:</p>
<ul>
<li><p><span class="math inline">\(O(logn)\)</span>, 更新一个线段树的过程与上述构造线段树的过程相同。当输入数组中位于<code>i</code>位置的元素被更新时，我们只需从这一元素对应的叶子结点开始，沿二叉树的路径向上更新至更结点即可。显然，这一过程是一个<code>O(logn)</code>的操作。其算法如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update(i, value):</span><br><span class="line">  i = i + n</span><br><span class="line">  segmentTree[i] = value</span><br><span class="line">  <span class="keyword">while</span> i &gt; <span class="number">1</span>:</span><br><span class="line">    i = i / <span class="number">2</span></span><br><span class="line">    segmentTree[i] = merge(segmentTree[<span class="number">2</span>*i], segmentTree[<span class="number">2</span>*i+<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>query:</p>
<ul>
<li><span class="math inline">\(O(logn)\)</span>, basically go through top to bottom.</li>
</ul></li>
<li><p>range_update &amp; range_query</p>
<ul>
<li>amotized <span class="math inline">\(O(logn)\)</span>, I mean if lazy update is involved,</li>
</ul></li>
</ul></li>
<li><p><strong>Advanced</strong>:</p>
<ul>
<li><p>discrete segment tree: you see the segment tree doesn't care what left right is ,so basically you can treat a range as a node if that range dot not split into small ranges.</p></li>
<li><p>lazy update: actually range_update can be done without lazy update worst case <span class="math inline">\(O(n)\)</span> , but if overlapping update happens, lazy update can actually helps. Lazy can be done with set/ maxormin_set/ add/ sub/</p></li>
</ul></li>
</ul>
<h4 id="binary-search-tree">1.2.1.2. binary search tree</h4>
<h5 id="vanila-search-tree">1.2.1.2.1. vanila search tree</h5>
<h5 id="red-black-tree">1.2.1.2.2. red-black tree</h5>
<h5 id="self-balance-tree">1.2.1.2.3. self-balance tree</h5>
<h5 id="splay-tree">1.2.1.2.4. splay tree</h5>
<h4 id="heap-1">1.2.1.3. heap</h4>
<h5 id="skew-heap">1.2.1.3.1. skew heap</h5>
<h5 id="heap-2">1.2.1.3.2. ..heap</h5>
<h4 id="huffman-tree">1.2.1.4. huffman tree</h4>
<ul>
<li><p><strong>Usage</strong>: huffman code</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200201153422750.png"></p></li>
<li><p><strong>Intuition</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200201153631576.png"></p></li>
</ul>
<h4 id="binary-index-tree">1.2.1.5. binary index tree</h4>
<ul>
<li><p><strong>Usage</strong>: BIT is used for efficient <code>update</code> &amp; <code>get_range_sum</code> operations</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200121164044574.png"></p></li>
<li><p><strong>Intuition/Structure</strong>: cut range_sum into slices to reduce the time of updates</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200121162945121.png"></p>
<p><strong>Note</strong>: so basically, the elements on <span class="math inline">\(i_{th}\)</span> layer, have i-1 ones in binary. And more importantly, have one more one after the last one of parent node (e.g. 8 is 10 00, 9 is 1001, 10 is 1010, 12 is 1100).So array[i] actually stores <code>(eliminate last 1 of i) + 1 -&gt; i</code>(e.g. array[8]=[1,8]) So, the prefix sum is actually summing up all the ones =&gt; sum(13) = sum(1000)+ sum(0100)+sum(0010) +sum(0001). So the update becomes eliminating all ones.</p></li>
<li><p><strong>Complexity</strong>:</p>
<ul>
<li><p>build tree:</p>
<ul>
<li><p><span class="math inline">\(O(nlogn)\)</span>: inary Indexed Tree的建立非常简单。我们只需初始化一个全为0的数组，并对原数组中的每一个位置对应的数字调用一次<code>update(i, delta)</code>操作即可。</p></li>
<li><p><span class="math inline">\(O(n)\)</span>: 此外，还存在一个O(n)时间简历Binary Indexed Tree的算法，其步骤如下(数组下标从0开始)：</p>
<p>给定一个长度为n的输入数组list。初始化长度为n + 1的Binary Indexed Tree数组bit，并将list中的数字对应地放在bit[1]到bit[n]的各个位置。对于1到n的每一个i，进行如下操作： 令j = i + (i &amp; -i)，若j &lt; n + 1，则bit[j] = bit[j] + bit[i]</p></li>
</ul></li>
<li><p>get_range_sum:</p>
<ul>
<li><p><span class="math inline">\(O(logn)\)</span>: 可以发现，在这棵抽象的树种向上移动的过程其实就是不断将当前数字的最后一个<code>1</code>翻转为<code>0</code>的过程, from bottom to parent to root。基于这一事实，实现在Binary Indexed Tree中向上（在数组中向前）寻找母结点的代码就非常容易了。例如给定一个<code>int x = 13</code>，这个过程可以用如下运算实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prefixSum(<span class="number">13</span>) = prefixSum(<span class="number">0b00001101</span>)</span><br><span class="line">  = BIT[<span class="number">13</span>] + BIT[<span class="number">12</span>] + BIT[<span class="number">8</span>]</span><br><span class="line">  = BIT[<span class="number">0b00001101</span>] + BIT[<span class="number">0b00001100</span>] + BIT[<span class="number">0b00001000</span>]</span><br><span class="line">x = <span class="number">13</span> = <span class="number">0b00001101</span></span><br><span class="line">-x = <span class="number">-13</span> = <span class="number">0b11110011</span></span><br><span class="line">x &amp; (-x) = <span class="number">0b00000001</span></span><br><span class="line">x - (x &amp; (-x)) = <span class="number">0b00001100</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>update:</p>
<ul>
<li><p><span class="math inline">\(O(logn)\)</span>: 从图中我们发现，从5开始，应当被更新的位置的坐标为原坐标加上原坐标二进制表示中最后一个1所代表的数字, 更新所有具有相同数量的1的比它大的节点以及一个一个去掉1的节点. 这一过程和上面求和的过程刚好相反。以<code>int x = 5</code>为例，我们可以用如下运算实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span> = <span class="number">0b00000101</span></span><br><span class="line">-x = <span class="number">-5</span> = <span class="number">0b11111011</span></span><br><span class="line">x &amp; (-x) = <span class="number">0b00000001</span></span><br><span class="line">x + (x &amp; (-x)) = <span class="number">0b00000110</span></span><br></pre></td></tr></table></figure>
<p>根据上面的分析，我们可以看出，对于长度为<code>n</code>的数组，单个<code>update</code>和<code>prefixSum</code>操作最多需要访问<code>logn</code>的元素，也就是说单个<code>update</code>和<code>prefixSum</code>操作的时间复杂度均为<code>O(logn)</code>。</p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="general-tree">1.2.2. general tree</h3>
<h4 id="b-tree">1.2.2.1. B tree</h4>
<ul>
<li><p><strong>Def</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215151542313.png"></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215151549042.png"></p></li>
<li><p><strong>Operations</strong>: https://blog.csdn.net/xiaojin21cen/article/details/99830864</p>
<ul>
<li><p><strong>Insertion</strong>: insert &amp; split</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215154256298.png"></p></li>
</ul></li>
</ul>
<h4 id="btree">1.2.2.2. B+tree</h4>
<p>https://www.jianshu.com/p/71700a464e97</p>
<h4 id="trie">1.2.2.3. Trie</h4>
<ul>
<li><p><strong>Usage</strong>:</p>
<ul>
<li><p>for searching 1 string in a set of strings(when they have overlapping prefixes).</p></li>
<li><p>for sorting in alphabetical order, very much like bucket sort.</p></li>
<li><p>for we want to do the opposite to see if set[b,c,d,e] is in a, we just recursively search a.</p></li>
</ul></li>
<li><p><strong>Intuition/Structure</strong>: a mapping technique</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200121215833534.png" alt="image-20200121215833534" style="zoom:50%;"></p></li>
<li><p><strong>Complexity</strong>:</p>
<ul>
<li>search: <span class="math inline">\(O(n)\)</span> , actually it depends on the dataset, if no prefix is overlapped then it's <span class="math inline">\(O(n)\)</span>, if all of them if overlapped, then it is <span class="math inline">\(O(1)\)</span></li>
</ul></li>
</ul>
<h1 id="problems-algorithms">2. problems &amp; algorithms</h1>
<ul>
<li><strong>Note</strong>: most of optimization problems of CS can be catagoried in combinatorial optimization, so here we consider only discrete math or CS problems. We use <code>Def</code> to denote the procedure of algorithm, <code>Usage &amp; Complexity</code> are the same.</li>
</ul>
<h2 id="search">2.1. search</h2>
<p>### divide &amp; concur</p>
<ul>
<li><p><strong>Usage</strong>: basically the base of all computer algorithms, to separate them to subproblems.</p></li>
<li><strong>Def</strong>: divide &amp; concur
<ul>
<li>find subproblem</li>
<li>improvise!</li>
</ul></li>
<li><p><strong>Complexity</strong>:</p>
<p>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>
<p><span class="math display">\[
 T（n）= a T(n/b)+f(n) \\
\begin{equation}  
T(n)=\left\{  
             \begin{array}{**lr**}  
             O(n ^{log_ba}) &amp; \text{if f(n)&lt;O(n^log(b,a))}  \\  
             O(n ^{log _{b}a} log_bn) &amp;  \text{if f(n) =} \\
             O(f(n)) &amp; \text{if f(n) &gt;}
             \end{array}  
\right.  
\end{equation}
\]</span></p></li>
</ul>
<h3 id="depth-first-search">2.1.1. depth first search</h3>
<ul>
<li><p><strong>Usage</strong>: a way of searching subproblems</p></li>
<li><p><strong>Def</strong>: depth first seach</p>
<ul>
<li>find subproblems</li>
<li>set the meaning for the same level</li>
<li>update next level status (how to search, or the propagation function)
<ul>
<li>make sure no affecting over searches(to prevent duplicate you can [+] =&gt; do search =&gt; [-] or change the searching setting (with no refence) the common technique))</li>
</ul></li>
<li>set iterative/ recursive
<ul>
<li>recursive =&gt; stop for{par_(lever+1)}<br>
</li>
<li>iterative(stack) array（necessary when special obervation simplifies problem)</li>
</ul></li>
<li>set terminal condition</li>
<li>see if trimming or other advanced tricks can be used</li>
</ul></li>
<li><p><strong>Advanced</strong>: （简而言之从两方面优化：（1）第一尽量在保证正确性的情况下减少分支（相当于找最小数量的不相交的子集覆盖整个搜索区域，当然可以使用幂集但是就太慢了.） （2）如果减少分支还是会在不同分支有重复，使用DP。（3）如果是maxmin问题，分支可能会有上下界的剪枝。</p>
<ul>
<li><p>different-node optimization: if searching encounters <code>exact same searching settings</code>, memorize it, consider</p>
<ul>
<li>is there possibility of encountering same searching settings on different levels?</li>
<li><p>is there any possibility that we cut those branches that doesn't affect optimal(usually on max/min problem)</p>
<ul>
<li>use a global store =&gt; other branches affect trimming, usually when no duplicated path in all searching paths.
<ul>
<li>examples: global visited[i][j] = 1: no duplicates</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>same-node optimization: if we want to trim dfs, it's actually a step of narrowing down the domain =&gt; for a specific problem, we see what is the actual domain(the set contains the optimal): consider</p>
<ul>
<li><p>is it full search(does it contain optimal?)</p></li>
<li><p>is there duplicates on the same level?(duplicate do not mean same problem, but it means unnecessary same outcome考虑是否重合可以从A分支是否包含B分支没有的内容或者相反来考虑 )) : e.g. sticker problem, going from the covering sequence is full and reduced duplicates, why? it is full since you can prove it by contrast, it is reduced because it cut off branches.</p>
<ul>
<li><p>use parameter update =&gt; previous same branch affect trimming.</p>
<ul>
<li>examples: &amp;grid[i][j] = 1</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>other specific problem requests optimization:</p>
<ul>
<li>if we want to return when we find a solution but not all solutions, we can terminate internally(by the next line after subproblem) or externally(by the entrance of subproblem).</li>
<li>if we want greedy in some circumstances(trim), then we have to return more than usual=&gt;return the status of result to trigger trimming.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="tail-recursive">2.1.1.1. tail recursive</h4>
<ul>
<li><p><strong>Def</strong>: tail recursive</p>
<p>顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p>
<p><strong>Note</strong>: 尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。</p>
<p><strong>Example</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FibonacciTailRecursive</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> ret1,<span class="keyword">int</span> ret2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> ret1; </span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> FibonacciTailRecursive(n<span class="number">-1</span>,ret2,ret1+ret2);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="breadth-first-search">2.1.2. breadth first search</h3>
<ul>
<li><strong>Usage</strong>: have to satisfy all otherwise we could use (DFS + meme + trim&gt;shortest)
<ul>
<li>when asked to find shortest and depth_tree &gt; shortest</li>
<li>when the same level information can help us with trimming.</li>
</ul></li>
<li><p><strong>Def</strong>: bfs</p>
<ul>
<li><p>find subproblem</p></li>
<li><p>set the meaning for the same level,</p>
<ul>
<li>set update status for next level (how to search, or the propagation function)</li>
<li>make sure not affecting other searches</li>
</ul></li>
<li><p>set iteration/ recursive (prefer recursive) =&gt;</p>
<ul>
<li>iterative: stop for{same level} onlyone(lever+1)</li>
<li>recursive: while(stop) { for{same level} update} (actually no need to recur)</li>
</ul></li>
<li><p>set terminal return or continue;</p></li>
<li><p>see if advanced technique can be used</p></li>
</ul></li>
<li><p><strong>Advanced</strong>:</p>
<ul>
<li>dp: avoid necessary branches</li>
<li>trimming: return before iteration;</li>
</ul></li>
</ul>
<h3 id="dynamic-programming">2.1.3. dynamic programming</h3>
<ul>
<li><p><strong>Usage</strong>: useful when you can separate subproblems</p></li>
<li><strong>Def</strong>: dynamic programming
<ul>
<li>find overlapped subproblem
<ul>
<li>technically, you can put the ans on index/value. (e.g. problem 871, putting ans which is the number of stations on value would be like dp[i] is the smallest number of stations from i to end, putting ans on index would be like i is the stations taken and dp[i] would be the max distance traveled.) to make it more accurate, we want to separate the problem by stations which is a natural thought, so DP[i] is a must-do. then we have the distance and number of stations taken which is information we can't throw away, solution 1: <code>dp[i][distance] = {number}</code>, solution 2: <code>dp[i] = {number &amp; distances}</code>, solution 3: <code>dp[i][number]={distances}</code>, apparently, solution3 is the easiest way since i and number are all integers.
<ul>
<li>other advanced technique i: if putting parameter on index is too costy, you can put it on value (e.g. 871, distance of travelling is an important parameter and if you put it on index it is too costy, so we choose the alternative, putting it on value.)</li>
</ul></li>
</ul></li>
<li><p>set a propagation equation</p>
<ul>
<li>for i-1 and i, it is important to make sure i-1 can be successfully propagated to i
<ul>
<li>for :i-1 i i+1:end, it is important to make sure that i-1 and i+1 are independent</li>
</ul></li>
</ul></li>
<li><p>set recursive or iteration</p>
<ul>
<li>iteration: find update sequence
<ul>
<li>output true/false</li>
<li>equation is easy (subproblem are easy to find, e.g. in a top-down manner ) || update sequence is easy to find( since this is what we want if we want bottom-up)</li>
<li>recursive: DFS related
<ul>
<li>output not int/bool (in this case will have to use a map)</li>
<li>propagation is hard (subproblem not easy to find, e.g. in a top-down manner)</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>set init values and margin conditions.</p></li>
</ul></li>
<li><p><strong>Advanced</strong>:</p>
<ul>
<li>time (bu vs td, time complexity = relationships * c.(why? because in bu all relationships are used to calculate every elements, in td every elements is used once(prove by contradiction, if twice then you are not saved)). Then, in bu c = operations, in td c = call&amp;return, so bu is more preferable! )</li>
<li>finding pivot indexes is more preferable using bottom-up implementation!</li>
<li>trimming: consider carefully which element is used, so like if max(dp[...]) is used, consider putting max in a single dp[i] so you can cut branches.</li>
</ul></li>
</ul>
<h3 id="binary-search">2.1.4. binary search</h3>
<ul>
<li><p><strong>Usage</strong>: useful when you can relate a problem to a monotone array.</p></li>
<li><p><strong>Def</strong>: binary search</p>
<ul>
<li><p>find subproblem(split in 2 subproblems)</p></li>
<li><p>set find a monotone array and ditch one of of problems (unique propagation equation), so monotone array is useful so we can easily trim one of the branches!</p></li>
<li><p>set recursive or iterative (perfer iterative since it make things easier)</p></li>
<li><p>set the margin conditions</p>
<ul>
<li>l&lt;r, l+r/2, if(array==1) r = mid, l = mid + 1, when array is 0000011111 and we want the first 1.</li>
</ul></li>
<li><p>l&lt;r, ceil(l+r/2.0), l = mid, if(array!=1) r = mid - 1; when array is 000001111 and we want the last 0, the point is to make sure [l, r] always have the thing you want.</p></li>
</ul></li>
</ul>
<h3 id="greedy-search">2.1.5. greedy search</h3>
<ul>
<li><p><strong>Usage</strong>: only special problems can use this. one way of trimming all other branches except for the greedy optimal one/ or a way of searching directly to the results instead of following a path of searching/ or directly solving subproblems</p></li>
<li><p><strong>Def</strong>: greedy search</p>
<ul>
<li>(think of greedy when searching is too large)</li>
<li>find the smallest problem and prove greedy optimality</li>
<li>prove that from smallest to i+1 using greedy(like a easy dp equation) is optimal (compare to not smallest to i+1)</li>
</ul></li>
<li><p><strong>Note</strong>: the hardest part is always proving optimality.</p></li>
</ul>
<h2 id="sort">2.2. sort</h2>
<h3 id="insertion-sort">2.2.1. insertion sort</h3>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>Iterate over all elements</p></li>
<li><p>For each element: Check if element is larger than largest value in sorted array</p></li>
</ol>
<p>​ If larger: Move on</p>
<p>​ If smaller: Move item to correct position in sorted array</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Insertion%20Sort.gif" alt="Insertion Sort"><figcaption>Insertion Sort</figcaption>
</figure>
<ul>
<li><p><strong>Note</strong>: Very inefficient for large datasets</p></li>
<li><p><strong>Note</strong>: Better than selection sort and bubble sort for small data sets,</p></li>
</ul></li>
</ul>
<h3 id="bubble-sort">2.2.2. bubble sort</h3>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>Iterate over all elements</p></li>
<li><p>For each element:</p></li>
</ol>
<p>​ Swap with next element if out of order</p>
<ol start="3" type="1">
<li>Repeat until no swaps needed</li>
</ol>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Bubble%20Sort.gif" alt="Bubble Sort"><figcaption>Bubble Sort</figcaption>
</figure>
<ul>
<li><p><strong>Note</strong>: Much worse than even insertion sort, Very inefficient for large datasets</p></li>
<li><p><strong>Note</strong>: Easy to detect if list is sorted,</p></li>
</ul></li>
</ul>
<h3 id="selection-sort">2.2.3. selection sort</h3>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>Iterate over all elements</p></li>
<li><p>For each element:</p></li>
</ol>
<p>​ If smallest element of unsorted sublist, swap with left-most unsorted element</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Selection%20Sort.gif" alt="Selection Sort"><figcaption>Selection Sort</figcaption>
</figure>
<ul>
<li><p><strong>Note</strong>: Very inefficient for large datasets</p></li>
<li><p><strong>Note</strong>: Low memory usage for small datasets</p></li>
</ul></li>
</ul>
<h3 id="merge-sort">2.2.4. merge sort</h3>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>Divide list into smallest unit (1 element)</p></li>
<li><p>Compare each element with the adjacent list</p></li>
<li><p>Merge the two adjacent lists</p></li>
</ol>
<ul>
<li><strong>Note</strong>:</li>
</ul>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Merge%20Sort%202-8473215.gif" alt="Merge Sort 2"><figcaption>Merge Sort 2</figcaption>
</figure>
<ul>
<li><p><strong>Note</strong>: Slightly worse than Quicksort in some instances, Still requires O(n) extra space</p></li>
<li><p><strong>Note</strong>: Nearly always O(nlog(n)), Can be parallelized, Better space complexity than standard Quicksort, High efficiency on large datasets</p></li>
</ul></li>
</ul>
<p>### quick sort</p>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>Choose a <strong>pivot</strong> from the array</p></li>
<li><p>Partition: Reorder the array by swapping so that all elements with values <em>less</em> than the pivot come before the pivot, and all values <em>greater</em> than the pivot come after. (fixing the last element)</p></li>
<li><p>Recursively apply the above steps to the sub-arrays</p></li>
</ol>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214200013055.png"></p>
<ul>
<li><p><strong>Note</strong>: partition</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214200028634.png"></p></li>
<li><p><strong>Note</strong>:</p></li>
</ul>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Quicksort.gif" alt="Quicksort"><figcaption>Quicksort</figcaption>
</figure>
<ul>
<li><p><strong>Note</strong>: Not stable (could swap equal elements), Worst case is worse than Merge Sort;</p></li>
<li><p><strong>Note</strong>: Can be modified to use O(log(n)) space, Can be parallelized, Very quick and efficient with large datasets</p></li>
</ul></li>
<li><p><strong>Complexity</strong>:</p>
<ul>
<li><p>worst case: <span class="math inline">\(O(n^2)\)</span></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214204542917.png"></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214205046188.png"></p></li>
<li><p>best case: <span class="math inline">\(O(n logn)\)</span></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214204721186.png"></p></li>
<li><p>expected case: <span class="math inline">\(O(n logn)\)</span></p></li>
</ul></li>
<li><p><strong>Alternative</strong>: random version</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214205007775.png"></p></li>
</ul>
<h3 id="heap-sort">2.2.5. heap sort</h3>
<ul>
<li><strong>Def</strong>: algorithm <img src="/2019/12/03/datastructure-algorithm/Heapsort.gif" alt="Heapsort"></li>
</ul>
<h3 id="count-sort">2.2.6. count sort</h3>
<ul>
<li><p><strong>Def</strong>: algorithm</p>
<ol type="1">
<li><p>count all elements</p></li>
<li><p>put them in correct order</p></li>
</ol>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214211827086.png"></p>
<ul>
<li><p><strong>Note</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214211838349.png"></p></li>
</ul></li>
<li><p><strong>Complexity</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214211909214.png"></p></li>
<li><p><strong>Qua</strong>: stable</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214212204273.png"></p></li>
</ul>
<h3 id="bucket-sort-improved-count-sort">2.2.7. bucket sort (improved count sort)</h3>
<ul>
<li><p><strong>Def</strong>:</p>
<ol type="1">
<li><p>put elements in the right bucket</p></li>
<li><p>sort each bucket</p></li>
</ol>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214213916677.png"></p></li>
<li><p><strong>Note</strong>: count sort = bucket sort with n buckets, insertion sort = bucket sort with 1 bucket.</p></li>
</ul>
<h3 id="radix-sort">2.2.8. radix sort</h3>
<ul>
<li><p><strong>Def</strong>:</p>
<p>stable sort on each radix</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214213010292.png"></p></li>
<li><p><strong>Complexity</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214213044981.png"></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200214213100185.png"></p></li>
</ul>
<h2 id="graph">2.3. graph</h2>
<h3 id="topological-sorting">2.3.1. topological sorting</h3>
<ul>
<li><strong>Usage</strong>: topo sort can be used to do longest path
<ul>
<li><strong>Note</strong>: any nodes on one layer are larger than connected last layer.</li>
</ul></li>
<li><strong>Def</strong>: bfs</li>
</ul>
<h3 id="shortest-path">2.3.2. shortest path</h3>
<h4 id="dijkstra">2.3.2.1. Dijkstra</h4>
<ul>
<li><p><strong>Usage</strong>: Dijkstra, no negative weight, from 1 point to other point</p></li>
<li><p><strong>Def</strong>: Dij</p>
<p>​ 1) choose a point with the smallest dis</p>
<p>​ 2) choose the nearest neighbor ( smallest cj)</p>
<p>​ 3) update all point cj</p>
<p>​ 4) set the point as updated()</p>
<ul>
<li><strong>Proof</strong>: proof is easy, but note the proof involves in trimming those larger than local smallest, this can not be used in longest path. You can see that the trimming actually trimmed other edges from updating other than the 'fixed' set. The conditions are <span class="math inline">\(c_ {ij} &gt; 0\)</span>. However in longest path, if and only if pj is non-increasing, or <span class="math inline">\(c_{ij} &lt;0\)</span>, this algorithm can be used. <span class="math display">\[
p_j = min(p_{smaller set}+cij) \\
p_j \text{ is non-decreasing}
\]</span></li>
</ul></li>
<li><p><strong>Note</strong>: actually a top-down implementation of bfs, using the feature of principle of optimality, 感觉像是DP算法的进一步优化版本，DP算法尽管有重叠子问题可以消除，但是dij算法还去掉了一些重叠子问题减少计算量（比如在第二个点固定的过程中就只考虑了第一个点的update，其他点都去掉了）</p></li>
<li><p><strong>Note</strong>: we can generalize the DP algorithm by fixing node by node.</p></li>
<li><p><strong>Complexity</strong>: <span class="math inline">\(O(e·logv)\)</span>： 在核心代码部分，最复杂的是 while 循环和 for 循环嵌套的部分，while 循环最多循环 v 次（v 为顶点个数），for 循环执行次数与边的数目有关，假设顶点数 v 的最大边数是 e。</p>
<p>for 循环中往优先队列中添加删除数据的复杂度为<code>O(log v)</code>。</p></li>
<li><p><strong>Qua</strong>: note that shortest path satisfy DP <span class="math display">\[
r_i = \min \limits_{j \in N(i)} (P _{ij} + rj)
\]</span></p>
<ul>
<li><strong>Proof</strong>: 1) when u-&gt;w-&gt;v and p'(u-&gt;w) is a shorter path than u-&gt;w, if p' have no overlap with w-&gt;v ,we simply replace u-&gt;w with p'</li>
</ul>
<p>​ 2) when u-&gt;w have overlap with w-&gt;v, we replace with u-&gt;x &amp; x-&gt;v where x is the overlapping point.</p>
<ul>
<li><strong>Note</strong>: that longest path can't prove by this procedure since u-&gt;x &amp; x-&gt; v is shorter not longer.</li>
</ul></li>
</ul>
<h4 id="floyd">2.3.2.2. Floyd</h4>
<ul>
<li><p><strong>Usage</strong>: Floyd, <code>D[i][j][k] means the the smallest distance between i and j considering only [1:k] nodes in bewteen</code></p></li>
<li><p><strong>Def</strong>: Floyd</p>
<p>​ 1) go from k = 1 -&gt; n</p>
<p>​ 2) update i &amp; j (at kth level )</p>
<ul>
<li><p><strong>Proof</strong>: when k = m, you can prove that with m nodes in between, the update is valid. If not, after the update, there exists some node gg $$ [1, m], and <span class="math inline">\(i^*\to gg + gg \to j^* &lt; i \to gg + gg \to j\)</span> , so that either i-&gt;gg or gg-&gt;n is not the smallest path.</p></li>
<li><p><strong>Note</strong>: intuition is if left is shortest path and right is shortest path then the middle is shortest path. we can generalize the DP algorithm by fixing layer by layer such that the update path only concerns k nodes.</p></li>
</ul></li>
<li><p><strong>Complexity</strong>: $O(n^3) $</p></li>
</ul>
<h4 id="bellman-ford">2.3.2.3. Bellman-Ford</h4>
<ul>
<li><p><strong>Usage</strong>: single source + negative</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216135431797.png"></p></li>
<li><p><strong>Def</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216135405007.png"></p>
<ul>
<li><strong>Note</strong>: every edge relaxation V-1 times, if can still relax</li>
</ul></li>
<li><p><strong>Complexity</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216142110276.png"></p></li>
</ul>
<h3 id="union-find">2.3.3. union find</h3>
<ul>
<li><p><strong>Usage</strong>:</p>
<ul>
<li>used to find if 2 elements are in the same category</li>
<li>used to find how many connect component/ circles are there</li>
<li>efficient when overlapping(changing many times for a single node)</li>
</ul></li>
<li><p><strong>Def</strong>:</p>
<ul>
<li>find the nodes</li>
<li>find the node union conditions (could use trick here to shorten n comparisons to constant m ).</li>
</ul></li>
<li><p><strong>Complexity</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200105235101400.png" style="zoom:50%;"></p></li>
</ul>
<h3 id="strongly-connected-components">2.3.4. strongly connected components</h3>
<ul>
<li><p><strong>Usage</strong>: to find SCC</p></li>
<li><p><strong>Def</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215195851066.png"></p></li>
<li><p><strong>Theorem</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215185049028.png"></p>
<ul>
<li><p><strong>Note</strong>: this theorem means we can draw a graph like this</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215220122368.png"></p></li>
</ul></li>
<li><p><strong>Theorem</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215220143020.png"></p>
<ul>
<li><strong>Note</strong>: this theorem means abe = 4 cd = 3 h = 2 fg =1, high goes to low. which means we revert the graph, and start from high, then all pathes from high to low are cut, then we can find the components.</li>
</ul></li>
</ul>
<h3 id="minimum-spanning-tree">2.3.5. minimum spanning tree</h3>
<ul>
<li><p><strong>Def</strong>: eliminate edge</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215233626966.png"></p></li>
<li><p><strong>Def</strong>: 切割</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216002021695.png"></p>
<ul>
<li><p><strong>Theorem</strong>: safe edge</p>
<p><img src="file:///Users/huangbenson/SteinsGate9.github.io/source/_posts/datastructure-algorithm/image-20200215233830446.png?lastModify=1581763828"></p></li>
</ul></li>
<li><p><strong>Def</strong>: Kruskal</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215233905979.png"></p>
<ul>
<li><p><strong>Note</strong>: add edges with no circle</p></li>
<li><p><strong>Complexity</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216003754336.png"></p></li>
</ul></li>
<li><p><strong>Def</strong>: prim</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215234610956.png"></p>
<ul>
<li><p><strong>Note</strong>:</p></li>
<li><p>Complexity:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200216003909764.png"></p></li>
</ul></li>
</ul>
<h2 id="amotized-analysis">2.4. amotized analysis</h2>
<h3 id="aggregate-analysis">2.4.1. aggregate analysis</h3>
<ul>
<li><p><strong>Def</strong>: think of all n operation together</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215003158269.png"></p></li>
</ul>
<h3 id="accounting-method">2.4.2. accounting method</h3>
<ul>
<li><p><strong>Def</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215003312699.png"></p>
<ul>
<li><p><strong>Note</strong>: key is to design cost .</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215004538426.png"></p></li>
</ul></li>
</ul>
<h3 id="potential-method">2.4.3. potential method</h3>
<ul>
<li><p><strong>Def</strong>:</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215003440903.png"></p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200215003451614.png"></p>
<ul>
<li><strong>Note</strong>: potential is actually a way of designing accounting method.</li>
</ul></li>
</ul>
<h2 id="other">2.5. other</h2>
<h3 id="moore-voting">2.5.1. moore-voting</h3>
<ul>
<li><strong>Usage</strong>: for finding mode</li>
<li><strong>Def</strong>: 摩尔投票法基于这样一个事实，<strong>当一个数的重复次数&gt;=数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。</strong> [candidate, count] =(at ith time) [candidate, the count candidate in [0:i] - other different], and when count &lt; 0 =&gt; we set candidate = num[i].
<ul>
<li><strong>Proof</strong>: ez proof, when count&gt;=0, it is always guaranteed, when count&lt;0, then elements before i is ruled out from the candidates, so we choose a new one.</li>
</ul></li>
</ul>
<h1 id="leetcode">3. Leetcode</h1>
<ul>
<li><p><strong>Note</strong>: here are the notes of leetcode problems, I think the way of analyzing a problem is to follow 2 steps:</p>
<ul>
<li><p>ways of solving: 1) searching? 2) greedy? 3) math proved?</p></li>
<li><p>ways of implementing: various data structures</p></li>
</ul></li>
</ul>
<h2 id="int">3.1. int</h2>
<h3 id="no.7-iterate-reverse-int">3.1.1. no.7 iterate &amp; reverse int</h3>
<ul>
<li>careful:
<ul>
<li>remember the INT_MAX &amp; INT_MIN, and that INT_MAX + 1 = INT_MIN</li>
<li>and that any int will trancate to [INT_MIN, INT_MAX] if overflow.</li>
<li>that string numbers n are bad for comparation.</li>
</ul></li>
</ul>
<h3 id="no.9-iterate-reverse-int-2">3.1.2. no.9 iterate &amp; reverse int 2</h3>
<ul>
<li>key:
<ul>
<li>observation: some can compare when all is flipped over.</li>
</ul></li>
<li>careful:
<ul>
<li>remember it is difficult to yield the first character of a int,</li>
</ul></li>
</ul>
<h3 id="no.13-iterate-assign">3.1.3. no.13 iterate &amp; assign</h3>
<ul>
<li><p>key:</p>
<ul>
<li>observation: examine the problem carefully</li>
</ul></li>
</ul>
<h2 id="string">3.2. string</h2>
<h3 id="no.28-iterate">3.2.1. no.28 iterate</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: can use substr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haystack.substr(i,len);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="no.859-iterate-swap">3.2.2. no.859 iterate &amp; swap</h3>
<ul>
<li>key:
<ul>
<li>observation: consider all circumtances</li>
</ul></li>
</ul>
<h2 id="vector-1">3.3. vector</h2>
<h3 id="no.26-iterate-eraseassign">3.3.1. no.26 iterate &amp; erase/assign</h3>
<ul>
<li><p>careful:</p>
<ul>
<li><p>vector after erase, iterator position change!!!, so reassgnment is neccesary(all iterators need to be reassigned), so erase is not preferable during iteration!.</p></li>
<li><p>try to use move &amp; assign tech instead of erase.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = gg.erase(a);</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="no.665-iterate-change-value-math-problem">3.3.2. no.665 iterate &amp; change value (math problem)</h3>
<ul>
<li>key:
<ul>
<li><p>observation:</p>
<ol start="0" type="1">
<li><p>注意这个算法只是（只改变一次的最优策略）这种情况，并非改变（改变最少次数）的全局最优。所以是局部最优解，但是考虑到只改变一次这种情况，就是i j出问题，那么解决i, j 必然要1次的变动。如果能用一次解决，所以改变i或者j其中一个一定能解决这个问题。所以考虑改变i和j能解决问题的区别，在默认改变一次能解决所有问题的假设下，只有一种情况改变j才能解决：就是以下情况。所以才这么做。</p></li>
<li><p>以上解释太蠢了，我们直接把所有四种情况能用一次改变解决的画出来即可，然后设计一个算法解决它，如果这个算法能解决，那么必然符合情况，不能解决就不符合。</p></li>
<li><p>that for every xi &gt; xj (i &lt; j), either i or j have to be changed, and of course we want i to change since i decrease can at most amend (n-i) relationships, and j increase may at most amend j relationships. since we go from i=0 to n-1, the left side of i we assume is already fixed. the only condition we prefer j over i is that j can change both i-k, i-m. so we push j into a set to prevent that from happening.</p></li>
</ol></li>
</ul></li>
</ul>
<h3 id="insert-interval">3.3.3. 57. Insert Interval</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation:</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; insert(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">-1</span>, e = <span class="number">-1</span>, sz = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!sz || newInterval[<span class="number">1</span>]&lt;intervals[<span class="number">0</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            intervals.insert(intervals.<span class="built_in">begin</span>(), newInterval);</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(newInterval[<span class="number">0</span>]&gt;intervals.back()[<span class="number">1</span>])&#123;</span><br><span class="line">            intervals.insert(intervals.<span class="built_in">end</span>(), newInterval);</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=intervals.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; e==<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s==<span class="number">-1</span> &amp;&amp; newInterval[<span class="number">0</span>]&lt;=intervals[i][<span class="number">1</span>] &amp;&amp; (i==<span class="number">0</span>?<span class="number">1</span>:newInterval[<span class="number">0</span>]&gt;intervals[i<span class="number">-1</span>][<span class="number">1</span>])) &#123;s = i;&#125;</span><br><span class="line">            <span class="keyword">if</span>(newInterval[<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>] &amp;&amp; (i==intervals.<span class="built_in">size</span>()<span class="number">-1</span>?<span class="number">1</span>:newInterval[<span class="number">1</span>]&lt;intervals[i+<span class="number">1</span>][<span class="number">0</span>])) &#123;e = i;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="number">-1</span>)&#123;</span><br><span class="line">            intervals.insert(intervals.<span class="built_in">begin</span>()+e+<span class="number">1</span>, newInterval);</span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; s &lt;&lt;<span class="string">" "</span>&lt;&lt; e &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        intervals[s] = &#123;<span class="built_in">min</span>(newInterval[<span class="number">0</span>], intervals[s][<span class="number">0</span>]), <span class="built_in">max</span>(newInterval[<span class="number">1</span>], intervals[e][<span class="number">1</span>])&#125;;</span><br><span class="line">        intervals.erase(intervals.<span class="built_in">begin</span>()+s+<span class="number">1</span>, intervals.<span class="built_in">begin</span>()+e+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> intervals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="insert-delete-getrandom-o1">3.3.4. 380. Insert Delete GetRandom O(1)</h3>
<ul>
<li>key
<ul>
<li>observation: random O(1) =&gt; vector, remove O(1) =&gt; hash map, combine those 2.</li>
</ul></li>
</ul>
<h2 id="linked-list">3.4. linked list</h2>
<ul>
<li><p>巧妙的构造虚拟头结点。可以使遍历处理逻辑更加统一。</p></li>
<li><p>灵活使用递归。构造递归条件，使用递归可以巧妙的解题。不过需要注意有些题目不能使用递归，因为递归深度太深会导致超时和栈溢出。</p></li>
<li><p>链表区间逆序。第 92 题。</p></li>
<li><p>链表寻找中间节点。第 876 题。链表寻找倒数第 n 个节点。第 19 题。只需要一次遍历就可以得到答案。</p></li>
<li><p>合并 K 个有序链表。第 21 题，第 23 题。</p></li>
<li><p>链表归类。第 86 题，第 328 题。</p></li>
<li><p>链表排序，时间复杂度要求 O(n * log n)，空间复杂度 O(1)。只有一种做法，归并排序，至顶向下归并。第 148 题。</p></li>
<li><p>判断链表是否存在环，如果有环，输出环的交叉点的下标；判断 2 个链表是否有交叉点，如果有交叉点，输出交叉点。第 141 题，第 142 题，第 160 题。</p></li>
</ul>
<h3 id="no.21-iterate-merge-2-list">3.4.1. no.21 iterate &amp; merge 2 list</h3>
<ul>
<li><p>careful:</p>
<ul>
<li>difference between while &amp; for , while: more flexible, for: be very carefull when operating linked list since for have this delayed feature.</li>
</ul></li>
</ul>
<h2 id="pointer">3.5. 2-pointer</h2>
<ul>
<li><p>双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 992 题，第 1004 题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">left, right := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> left &lt; len(s) &#123;</span><br><span class="line">    <span class="keyword">if</span> right+<span class="number">1</span> &lt; len(s) &amp;&amp; freq[s[right+<span class="number">1</span>]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line">        freq[s[right+<span class="number">1</span>]-<span class="string">'a'</span>]++</span><br><span class="line">        right++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        freq[s[left]-<span class="string">'a'</span>]--</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">max</span>(result, right-left+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>快慢指针可以查找重复数字，时间复杂度 O(n)，第 287 题。</p></li>
<li><p>替换字母以后，相同字母能出现连续最长的长度。第 424 题。</p></li>
<li><p>SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题。</p></li>
</ul>
<h2 id="sliding-window">3.6. sliding window</h2>
<ul>
<li><p>双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">left, right := <span class="number">0</span>, <span class="number">-1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> left &lt; len(s) &#123;</span><br><span class="line">    <span class="keyword">if</span> right+<span class="number">1</span> &lt; len(s) &amp;&amp; freq[s[right+<span class="number">1</span>]-<span class="string">'a'</span>] == <span class="number">0</span> &#123;</span><br><span class="line">        freq[s[right+<span class="number">1</span>]-<span class="string">'a'</span>]++</span><br><span class="line">        right++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        freq[s[left]-<span class="string">'a'</span>]--</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">max</span>(result, right-left+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>滑动窗口经典题。第 239 题，第 480 题。</p></li>
</ul>
<h2 id="stack-1">3.7. stack</h2>
<ul>
<li><p>括号匹配问题及类似问题。第 20 题，第 921 题，第 1021 题。</p></li>
<li><p>栈的基本 pop 和 push 操作。第 71 题，第 150 题，第 155 题，第 224 题，第 225 题，第 232 题，第 946 题，第 1047 题。</p></li>
<li><p>利用栈进行编码问题。第 394 题，第 682 题，第 856 题，第 880 题。</p></li>
<li><p><strong>单调栈</strong>。利用栈维护一个单调递增或者递减的下标数组。第 84 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题。</p></li>
</ul>
<h3 id="push-pop">3.7.1. 20. push &amp; pop</h3>
<h3 id="xxx.-simplify-path">3.7.2. xxx. Simplify Path</h3>
<h3 id="xxx.-basic-calculator">3.7.3. xxx. Basic Calculator</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: no need to keep all items since there are no */. keep a stack of signes and do +-.</p>
<p><code>Example: 7 - ( 6 - 5 - ( 4 - 3 ) - 2 ) - ( 1 ) Result:</code>+<code>7</code>-<code>6 + 5</code>+<code>4 - 3 + 2</code>-<code>1</code></p></li>
</ul></li>
</ul>
<h3 id="section">3.7.4. </h3>
<ul>
<li>careful
<ul>
<li>can't use iterator to change value!</li>
</ul></li>
</ul>
<h3 id="remove-k-digits">3.7.5. 402. Remove K Digits</h3>
<ul>
<li>key
<ul>
<li>observation: result ith = smallest of[result i-1th:k-previous used]</li>
</ul></li>
</ul>
<h3 id="sum-of-subarray-minimums">3.7.6. 907 Sum of Subarray Minimums</h3>
<ul>
<li>key
<ul>
<li>observation: result = sum(PLE(A[i]) * NLE(A[i])), so, stack.</li>
</ul></li>
</ul>
<h3 id="pattern">3.7.7. 456 132 Pattern</h3>
<ul>
<li>key</li>
</ul>
<h3 id="largest-rectangle-in-histogram">3.7.8. Largest Rectangle in Histogram</h3>
<ul>
<li>key
<ul>
<li>same as <a href="https://leetcode.com/problems/sum-of-subarray-minimums" target="_blank" rel="noopener">Sum of Subarray Minimums</a></li>
</ul></li>
</ul>
<h3 id="maximal-rectangle">3.7.9. 85. Maximal Rectangle</h3>
<ul>
<li>key
<ul>
<li>same as <a href="https://leetcode.com/problems/largest-rectangle-in-histogram" target="_blank" rel="noopener">Largest Rectangle in Histogram</a></li>
</ul></li>
</ul>
<h3 id="remove-duplicate-letters">3.7.10. Remove Duplicate Letters</h3>
<ul>
<li><p>key</p>
<ul>
<li>stack is used to simply keep a non-increasing array.</li>
</ul></li>
</ul>
<h3 id="odd-even-jump">3.7.11. 975 Odd Even Jump</h3>
<ul>
<li><p>key</p>
<ul>
<li>dp provide us with a way of solving this: only we have to solve the next smallerst higher / next lartest smaller, use index stack!</li>
</ul></li>
</ul>
<h3 id="trapping-rain-water">3.7.12. 42. Trapping Rain Water</h3>
<ul>
<li>key
<ul>
<li>observation: fill gap step by step: every gap is filled when left_bar &lt; right_bar or left-1_bar &lt; right_bar when encoutering higher bar, so a decreasing stack is needed.</li>
</ul></li>
</ul>
<h2 id="heap-3">3.8. heap</h2>
<h3 id="the-skyline-problem-i-wouldnt-say-its-divideconcurd">3.8.1. the skyline problem (i wouldn't say it's divide&amp;concurd)</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: first we need to observe that skyrim point is on every point when maximum height changes.</p>
<p><img src="/2019/12/03/datastructure-algorithm/image-20191210210016705.png"></p>
<p>thus, our priority is to efficiently update every maximum height.</p></li>
<li><p>algorithm1: we can do linear check =&gt; O(n + m*p)</p></li>
<li><p>algorithm2: we can do linear check with a heap so that we don't have to recheck the overlapping space, =&gt;O(n+ m *log(m/2))</p></li>
</ul></li>
<li><p>carefull</p>
<ul>
<li>== (?:)</li>
</ul></li>
<li><p>int+1 =&gt; overflow</p>
<ul>
<li>try to make things easier =&gt; observation is the most important .</li>
</ul></li>
</ul>
<h3 id="find-k-th-smallest-pair-distance">3.8.2. 719. Find K-th Smallest Pair Distance</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation; this is an obvious heap problem, but to reduce complexity, you have to go from the most possible (th &lt; k) elements to reduce times of poping, draw a map and use heap to find.</li>
</ul></li>
</ul>
<h3 id="find-median-from-data-stream">3.8.3. 295. Find Median from Data Stream</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: you want local maximum of lower half values and local minimum of higher half values.</p>
<p>start =&gt; I want know the local maxnimum of lower half, but not knowing the upper half is impossible since sometimes we 'll need to shift big stuff down. noticing that shifting only concern with smallest item of upper half, so that's heap.</p></li>
</ul></li>
</ul>
<h3 id="trapping-rain-water-ii">3.8.4. 407. Trapping Rain Water II</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: one points's element = min(largest surrounding set), a heap is used for the local min.</p>
<p>so we keep min queue as surrounding set and move step by step by poping the smallest(why smallest? because smallest ensure that the updated stuff is valid).</p>
<p><strong>Proof</strong>: by setting the surrouding as peripheral, and updating each element making sure that the updated element is either filled or higher. The queue itself maintain the [smallest of largest wall] as it's top(). we prove it by deduction, if at i-1 th time it is the smallest of largest wall, then at i th time we pop the smallest and add it's peripherals, so for the unupdated elements which is at the queue's peripherals, the smallest either remain unchanged or is updated by the pushing operations, so updated operations either push &gt; 1nd smallest at i-1 time, or == 1nd smallest at i-1 time, either way the smallest of largest wall remain true!.</p>
<p><strong>Note</strong>: that if trapping in 1D, the largest surrounding is equivalent to largest left + largest right, so a stack will suffice instead of maintaining a largest surrounding heap.</p></li>
</ul></li>
</ul>
<h3 id="k-th-smallest-prime-fraction">3.8.5. 786. K-th Smallest Prime Fraction</h3>
<ul>
<li>key
<ul>
<li>observation: same as 719: find kth smallest in n sorted vectors.</li>
</ul></li>
</ul>
<h3 id="minimum-cost-to-hire-k-workers">3.8.6. 857. Minimum Cost to Hire K Workers</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: <code>DP[i] means the optimal that pivot worker being i</code> , the problem can reduce to min(dp[i]), DP[i] = pivot(wv/qv) * sum(qv+otherq). I first think that set all pivot workers and solve them separately, then I found that sum(otherq) overlaps between DP[i] and DP[i-1], since otherq = sum smallest of quality of K-1 items from (i-1:end), so DP[i] and DP[i-1] overlaps, sum(i:end) = if i &gt; largest of i+1:end ? sum(i+1:end) : i + sum(i+1:end)-top() =&gt; use a heap to get top().</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_4756.JPG" alt="IMG_4756"><figcaption>IMG_4756</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="swim-in-rising-water">3.8.7. 778. Swim in Rising Water</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: when smaller numbers&lt;=T are connected together =&gt; use a priority heap to do DFS.</p>
<p><strong>Proof</strong>: only condition that poping number &gt; T is there's no other &lt;= T left in heap, but no other &lt;= T left in heap is that all heap is poped out to the edge since they are all connected.</p></li>
</ul></li>
</ul>
<h2 id="deque">3.9. deque</h2>
<h3 id="sliding-window-maximum">3.9.1. 239. Sliding Window Maximum</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: if we can keep the max order of current window, then on next level, we can do max stack(if we encounters a larger nums[i], then previous i-1:start that smaller than nums[i] won't work. so we can actually pop them out), so this is a decreasing stack problem. (why deque? because we need to pop the front as well when the front is out of the window)</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_4560.JPG" alt="IMG_4560"><figcaption>IMG_4560</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="maphash-table">3.10. map(hash table)</h2>
<h3 id="odd-even-jump-1">3.10.1. 975. Odd Even Jump</h3>
<ul>
<li>key
<ul>
<li>map direct usage</li>
</ul></li>
</ul>
<h3 id="maximum-frequency-stack">3.10.2. Maximum Frequency Stack</h3>
<ul>
<li>key
<ul>
<li>observation: separate problem to same frequency=&gt; first we do pop on max_stack, if max_stack is gone, we do pop on max-1_stack, then it's natural to use multiple map_stacks to store both frequency and stack orders. You can consider freq as the first priority and stack order as the second.</li>
</ul></li>
</ul>
<h3 id="maximum-xor-of-two-numbers-in-an-array">3.10.3. 421 Maximum XOR of Two Numbers in an Array</h3>
<ul>
<li>key
<ul>
<li>observation: for each bit, we want it from 31-&gt;1 since it requires the maximum. So, we see if there exists 2 elements that have different on first bit, then we move to second bit. One word, just think by endf</li>
</ul></li>
</ul>
<p>### 715. Range Module</p>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(logn)\)</span> observation: Use a map to save the disjoint intervals. For example, <code>m[left] = right</code> means there is an interval <code>[left, right)</code>.</p>
<p><code>addRange</code>: Apply <code>removeRange(left, right)</code> at first. Then add a new interval <code>[left, right)</code> in the map. Finally merge the previous interval and the next interval with <code>[left, right)</code> respectively, if they are adjcent.</p>
<p><code>queryRange</code>: Use <code>m.upper_bound(left)</code> to find the first interval <code>i</code> that <code>i.left &gt; left</code>. Then we know <code>prev(i).left &lt;= left</code>. If <code>prev(i).right &gt;= right</code>, we should return true, otherwise false.</p>
<p><code>removeRange</code>: Find the last interval <code>i</code> that <code>i.left &lt; left</code>. It is also the first interval which this delete operation may influence on. Then check all the intervals after <code>i</code>which intersects with <code>[left, right)</code>. Apply delete operation for each interval.</p></li>
</ul></li>
</ul>
<h2 id="union-find-1">3.11. union find</h2>
<ul>
<li><p>灵活使用并查集的思想，熟练掌握并查集的<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fhalfrost%2FLeetCode-Go%2Fblob%2Fmaster%2Ftemplate%2FUnionFind.go" target="_blank" rel="noopener">模板</a>，模板中有两种并查集的实现方式，一种是路径压缩 + 秩优化的版本，另外一种是计算每个集合中元素的个数 + 最大集合元素个数的版本，这两种版本都有各自使用的地方。能使用第一类并查集模板的题目有：第 128 题，第 130 题，第 547 题，第 684 题，第 721 题，第 765 题，第 778 题，第 839 题，第 924 题，第 928 题，第 947 题，第 952 题，第 959 题，第 990 题。能使用第二类并查集模板的题目有：第 803 题，第 952 题。第 803 题秩优化和统计集合个数这些地方会卡时间，如果不优化，会 TLE。</p></li>
<li><p>并查集是一种思想，有些题需要灵活使用这种思想，而不是死套模板，如第 399 题，这一题是 stringUnionFind，利用并查集思想实现的。这里每个节点是基于字符串和 map 的，而不是单纯的用 int 节点编号实现的。</p></li>
<li><p>有些题死套模板反而做不出来，比如第 685 题，这一题不能路径压缩和秩优化，因为题目中涉及到有向图，需要知道节点的前驱节点，如果路径压缩了，这一题就没法做了。这一题不需要路径压缩和秩优化。</p></li>
<li><p>灵活的抽象题目给的信息，将给定的信息合理的编号，使用并查集解题，并用 map 降低时间复杂度，如第 721 题，第 959 题。</p></li>
<li><p>关于地图，砖块，网格的题目，可以新建一个特殊节点，将四周边缘的砖块或者网格都 union() 到这个特殊节点上。第 130 题，第 803 题。</p></li>
<li><p>能用并查集的题目，一般也可以用 DFS 和 BFS 解答，只不过时间复杂度会高一点。</p></li>
</ul>
<h3 id="couples-holding-hands">3.11.1. 751 Couples Holding Hands</h3>
<ul>
<li>key
<ul>
<li>observation: nodes are cuples 1=&gt;n/2, at [0,1], [2,3] we find if cuples are connected(not the same), if at those seats they do no not seat together, we put cuples A &amp; B seet there connected. we out put the connected components K and N-K.</li>
</ul></li>
<li>careful
<ul>
<li>reserve = capacity, resize = size</li>
</ul></li>
</ul>
<h3 id="redundant-connection-ii">3.11.2. 685. Redundant Connection II</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: use union find to efficiently find circle</p>
<p>the only special case is case2 where you have to cut the last edge =&gt; we have to determine if there's other circle =&gt; we can't do circle detection on this edge.</p></li>
</ul></li>
</ul>
<h3 id="largest-component-size-by-common-factor">3.11.3. 952. Largest Component Size by Common Factor</h3>
<ul>
<li>key:
<ul>
<li><span class="math inline">\(O(n^2logM)\)</span> observation: union find is obvious, use gcd.</li>
<li><span class="math inline">\(O(n M^{1/2})\)</span> observation: kind of like bucket sort, where you store all possible n connections instead of comparing them every time.</li>
</ul></li>
</ul>
<h3 id="bricks-falling-when-hit">3.11.4. 803. Bricks Falling When Hit</h3>
<ul>
<li>key
<ul>
<li>observation: 由0和1组成的矩阵，每次给定一个1敲掉，把敲掉后不与首行的1相连通的1一并都抹除。问每次敲一共会抹除多少元素。查与之连通的元素用union find。union find适合将两个component连起来，这里却需要把连起来的拆开，并查集并无法快速支持这样的操作，要尽量把敲掉替换成并查集擅长的union操作。因此把敲掉看作倒着的补齐操作，每次补上元素后新增加与首行1相连的元素即敲掉元素所失去的元素。并查集还有个常用的小优化，即生成一个dummy src连接所有的首行1形成一个大component，这样只需要查一次src的size就知道所有与首行1连通的元素数目。</li>
</ul></li>
</ul>
<h3 id="minimize-malware-spread-ii">3.11.5. 928. Minimize Malware Spread II</h3>
<ul>
<li>key
<ul>
<li>$ O(n^2)$ observation: same as 803 in some way, start from no hits and add them separately, count the consequencies when hitting happens.</li>
<li>optimization: at first I thought i should connect initials one by one with other initials connected, actually only need to connect initials with other initials unconnected</li>
</ul></li>
</ul>
<h3 id="minimize-malware-spread">3.11.6. 924. Minimize Malware Spread</h3>
<ul>
<li>key
<ul>
<li>observation, same as 928, a little adjustment, contraints become more strict: First, a node have to connect to no other initials, Second, a node have to connect to no other initials infected fields.</li>
</ul></li>
</ul>
<h3 id="longest-consecutive-sequence">3.11.7. 128. Longest Consecutive Sequence</h3>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(n^2)\)</span> observation: do union find on nodes;</li>
<li><span class="math inline">\(O(n)\)</span> observation: do union find on nodes if nodes exist.</li>
</ul></li>
</ul>
<h3 id="similar-string-groups">3.11.8. 839. Similar String Groups</h3>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(n^2 *m)\)</span>:</li>
<li><span class="math inline">\(O(n*m^2)\)</span>:</li>
</ul></li>
</ul>
<h3 id="most-stones-removed-with-same-row-or-column">3.11.9. Most Stones Removed with Same Row or Column</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(n^2)\)</span> observation1: connect the stones which is pretty much straight forward.</p></li>
<li><p><span class="math inline">\(O(n)\)</span> obsevation2: intuition: node is only concerned with its coordinates. so connect the coordinates ?? which is tricky and not straight forward. don't need to know the exact parents, just need to know to component counts.</p>
<p><strong>Proof</strong>: a node is connected to another if and only if it's coordinate is connected, so we if 3 groups of node are connected, then there must exists 3 groups of coordinates.</p></li>
</ul></li>
</ul>
<p>### regionsBySlashes</p>
<ul>
<li>key
<ul>
<li>observation: key point of this problem is how to separate node easily, first thought is consider '/' as 0,1 and '\' as 3,4 the point is you have to look ahead what's adj to determine what to merge</li>
<li>optimization: split into 4 nodes,  / will different from connecting the same nodes different parts and since comparatively positions are fixed, don't have to look ahead which is very tedious work.</li>
</ul></li>
</ul>
<h2 id="bt">3.12. bt</h2>
<h3 id="binary-tree-postorder-traversal">3.12.1. Binary Tree Postorder Traversal</h3>
<ul>
<li>key:
<ul>
<li>stack implement traversal is all the same(DFS), post/pre/mid is just the time to push in value</li>
</ul></li>
</ul>
<h3 id="sum-of-distances-in-tree">3.12.2. 834. Sum of Distances in Tree</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: RES[i] = sum of all before[i]</p></li>
<li><p>optimization: compute RES[root] &amp; RES[i] = RES[i-&gt;parent] + countbeforei - countafteri.</p>
<p><strong>Note</strong>: you can see that we don't need to keep vector of all sum, since it's all 1s, we only need the counting of before and sum of vector.</p></li>
</ul></li>
</ul>
<h3 id="lca">3.12.3. 236. LCA</h3>
<ul>
<li>key
<ul>
<li>observation: ez dfs</li>
</ul></li>
</ul>
<h3 id="construct-binary-tree-from-inorder-and-postorder-traversal">3.12.4. 106. Construct Binary Tree from Inorder and Postorder Traversal</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: you can see that postorder cut the tree by right sub and midorder have the advantage of cutting the tree to left &amp; right.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">merge</span><span class="params">(TreeNode* r1, TreeNode* r2, <span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> merge = <span class="keyword">new</span> TreeNode(a); merge-&gt;left = r1; merge-&gt;right = r2;</span><br><span class="line">        <span class="keyword">return</span> merge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) &#123;<span class="keyword">return</span> <span class="literal">nullptr</span>;&#125; <span class="keyword">if</span>(left==right) &#123;<span class="keyword">new</span> TreeNode(inorder[right]);&#125;</span><br><span class="line">        <span class="keyword">int</span> pivix = postorder[start--]; <span class="keyword">auto</span> f = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), pivix)-inorder.<span class="built_in">begin</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> g = buildTree(inorder, postorder, f+<span class="number">1</span>, right), i = buildTree(inorder, postorder, left, f<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> merge(i, g, pivix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        start = inorder.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="keyword">if</span>(start==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, postorder, <span class="number">0</span>, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="bst">3.13. bst</h2>
<h3 id="count-of-smaller-numbers-after-self-from-dc">3.13.1. 315. Count of Smaller Numbers After Self (from D&amp;C)</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: this is actually from D&amp;C algorithm2:</p>
<p>=&gt; cur[i] = smaller[i+1:end] =&gt; insert cur[i] into [i+1:end] and see how many is smaller.(this is usage of BST)</p></li>
</ul></li>
</ul>
<h3 id="delete-bst">3.13.2. 450 delete BST</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==null) <span class="keyword">return</span> null ;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key) root.left=deleteNode(root.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key) root.right = deleteNode(root.right,key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(root.left==null) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span>(root.right==null) <span class="keyword">return</span> root.left;</span><br><span class="line">            </span><br><span class="line">            TreeNode rightmin = findmin(root.right);</span><br><span class="line">            root.val = rightmin.val;</span><br><span class="line">            root.right = deleteNode(root.right,root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findmin</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root.left!=null)</span><br><span class="line">            root=root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>careful</p>
<ul>
<li>avoid reference return between functions, do it in one function if possible.</li>
</ul></li>
</ul>
<h3 id="count-complete-tree-nodes">3.13.3. 222. Count Complete Tree Nodes</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(n)\)</span> observation: BFS</p></li>
<li><p><span class="math inline">\(O(log(n)^2)\)</span> observation: divide tree into 2 parts, at least one part is perfect, so basically</p>
<p>count = count(left or right) + full tree.</p></li>
</ul></li>
</ul>
<h3 id="bst-iterator">3.13.4. BST iterator</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: instead of doing BST recursive visits, we can store BST in stack</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  TreeNode *tmpNode = myStack.top();</span><br><span class="line">  myStack.pop();</span><br><span class="line">  pushAll(tmpNode-&gt;right);</span><br><span class="line">  <span class="keyword">return</span> tmpNode-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; node != <span class="literal">NULL</span>; myStack.push(node), node = node-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Proof</strong>: at node i we prove the next node is it's next, if no right=&gt; next is parent, if right =&gt; next is right sub tree's leftiest. or you can simply think of straps of nodes</p></li>
</ul></li>
</ul>
<h2 id="segment-tree-1">3.14. segment tree</h2>
<ul>
<li><p>线段数的经典数组实现写法。将合并两个节点 pushUp 逻辑抽象出来了，可以实现任意操作(常见的操作有：加法，取 max，min 等等)。第 218 题，第 303 题，第 307 题，第 699 题。</p></li>
<li><p>计数线段树的经典写法。第 315 题，第 327 题，第 493 题。</p></li>
<li><p>线段树的树的实现写法。第 715 题，第 732 题。</p></li>
<li><p>区间懒惰更新。第 218 题，第 699 题。</p></li>
<li><p>离散化。离散化需要注意一个特殊情况：假如三个区间为 [1,10] [1,4] [6,10]，离散化后 x[1]=1,x[2]=4,x[3]=6,x[4]=10。第一个区间为 [1,4]，第二个区间为 [1,2]，第三个区间为 [3,4]，这样一来，区间一 = 区间二 + 区间三，这和离散前的模型不符，离散前，很明显，区间一 &gt; 区间二 + 区间三。正确的做法是：在相差大于 1 的数间加一个数，例如在上面 1 4 6 10 中间加 5，即可 x[1]=1,x[2]=4,x[3]=5,x[4]=6,x[5]=10。这样处理之后，区间一是 1-5 ，区间二是 1-2 ，区间三是 4-5 。</p></li>
<li><p>灵活构建线段树。线段树节点可以存储多条信息，合并两个节点的 pushUp 操作也可以是多样的。第 850 题，第 1157 题。</p></li>
</ul>
<h3 id="online-majority-element-in-subarray">3.14.1. 1157. Online Majority Element In Subarray</h3>
<ul>
<li>key
<ul>
<li>observation <span class="math inline">\(O(logn)\)</span> : actually not a good way to use moore-vote + segment tree since, moore-vote requires threshold to be met, however we do not know if it is met, so we have to do additional check (e.g. a binary search on indexes) which makes it too chunky.</li>
</ul></li>
</ul>
<h3 id="falling-squares">3.14.2. 699 Falling Squares</h3>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(logn)\)</span> observation: discrete max_segment_tree problem, ez.</li>
</ul></li>
</ul>
<h3 id="rectangle-area-ii">3.14.3. 850. Rectangle Area II</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>$O(nm) $ observation: just set them all</p></li>
<li><p>$O(nm ) $ observation: discretion, decrease complexity by cutting into rectangles instead of node by node.</p></li>
<li><p><span class="math inline">\(O(n logn)\)</span> observation: discretion + update using sum Segment_tree</p></li>
</ul></li>
</ul>
<h3 id="my-calendar-iii">3.14.4. 732. My Calendar III</h3>
<ul>
<li><p>key</p>
<ul>
<li><span class="math inline">\(O(t^2)\)</span> solution: step by step discretion .</li>
</ul></li>
</ul>
<h2 id="trie-1">3.15. Trie</h2>
<h3 id="number-of-valid-words-for-each-puzzle">3.15.1. 1178. Number of Valid Words for Each Puzzle</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: find if string in a set of strings,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> countEnd;</span><br><span class="line">        TrieNode* children[<span class="number">26</span>];</span><br><span class="line">        TrieNode() &#123;</span><br><span class="line">            countEnd = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(children, <span class="number">0</span>, <span class="keyword">sizeof</span>(TreeNode*)*<span class="number">26</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TrieNode trie;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> countChar[<span class="number">26</span>])</span> </span>&#123;</span><br><span class="line">        TrieNode * currNode = &amp; trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countChar[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currNode-&gt;children[i] == <span class="literal">nullptr</span>)</span><br><span class="line">                    currNode-&gt;children[i] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                currNode = currNode-&gt;children[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        currNode-&gt;countEnd ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> countChar[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(countChar, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">26</span>);</span><br><span class="line">            <span class="built_in">string</span> &amp; w = words[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c: w) &#123; countChar[c-<span class="string">'a'</span>] = <span class="number">1</span>; &#125;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123; count += countChar[i]; &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">7</span>) <span class="keyword">continue</span>;</span><br><span class="line">            insert(countChar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(TrieNode* node, <span class="built_in">string</span> &amp; p, <span class="keyword">int</span> idx, <span class="keyword">char</span> firstChar, <span class="keyword">bool</span> metFirst)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;countEnd &gt; <span class="number">0</span> &amp;&amp; metFirst) &#123;</span><br><span class="line">            res += node-&gt;countEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = idx; i &lt; p.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[p[i]-<span class="string">'a'</span>] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                res += search(node-&gt;children[p[i]-<span class="string">'a'</span>], p, i+<span class="number">1</span>, firstChar, metFirst || (p[i] == firstChar));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumOfValidWords(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; puzzles) &#123;</span><br><span class="line">        buildTrie(words);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> firstChar = puzzles[i][<span class="number">0</span>];</span><br><span class="line">            sort(puzzles[i].<span class="built_in">begin</span>(), puzzles[i].<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">int</span> cnt = search(&amp;trie, puzzles[i], <span class="number">0</span>, firstChar, <span class="literal">false</span>);</span><br><span class="line">            res.push_back(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="longest-univalue-path">3.15.2. 687. Longest Univalue Path</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: <code>DP[node] = longest path from node</code> <span class="math display">\[
DP[node] = max(\\DP[left]if(v==v-&gt;left),\\
DP[right]if(v==v-&gt;right) )
\]</span></li>
</ul></li>
</ul>
<h3 id="vertical-order-traversal-of-a-binary-tree">3.15.3. 987. Vertical Order Traversal of a Binary Tree</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: use map ...</li>
</ul></li>
</ul>
<h3 id="section-1">3.15.4. </h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: searching n in 1 tree is trivial, searching 1 in n tree is the right solution, and you can see that the only condition that we get res = 1 is we finish the way alone the pattern&amp;word, is that we finish both lower and upper, and lower can be more, but upper is exactly the same.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(TrieNode* root, <span class="built_in">string</span> &amp; p, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; res, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">islower</span>(p[start])?p[start]-<span class="string">'a'</span>:p[start]-<span class="string">'A'</span>+<span class="number">26</span>;</span><br><span class="line">    <span class="keyword">if</span>(start!=p.length())&#123;</span><br><span class="line">        search(root-&gt;children[index], p, res, start+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">25</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(j!=index) search(root-&gt;children[j], p, res, start);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(start==p.length()) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">25</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;_countEnd!=<span class="number">-1</span>) res[root-&gt;_countEnd]=<span class="literal">true</span>;</span><br><span class="line">        search(root-&gt;children[j], p, res, start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="top-k-frequent-words">3.15.5. 692. Top K Frequent Words</h3>
<ul>
<li><p>key</p></li>
<li><p><span class="math inline">\(O(n+k)\)</span> observation: It is a must-have to map a word to its frequency. Since we aim to get k words with largest frequency, we have to map frequency to words and sort frequency decreasingly. Heap or TreeMap achieve that with O(n log k) time complexity, however, we could do better using Bucket Sort that takes O(n + k) time complexity for n is number of elements and k is number of buckets. Since we have to output words lexicographically, we take advantage of Trie for it has no sorting costs. That is, we build a trie consists of all words within the same bucket. And we apply DFS to traverse the trie and add words we met to the result list one by one. Finally, we go through buckets from tail to head until we get top K frequent words.</p></li>
</ul>
<h3 id="prefix-and-suffix-search">3.15.6. 745. Prefix and Suffix Search</h3>
<ul>
<li>key
<ul>
<li>observation: a seriously complicated trie tree problem, the DFS is serious mind-melting</li>
</ul></li>
</ul>
<h2 id="graph-1">3.16. graph</h2>
<ul>
<li><p>usage:</p>
<ul>
<li>dij is a special form of DP, DP[set()] means that value in set() is all updated and DP[set()]-&gt;...DP[{start}], so dij is actually building this DP bottom up by adding an element into set at each step.</li>
<li>topo_sort can efficiently compute max_height</li>
</ul></li>
</ul>
<h3 id="reachable-nodes-in-subdivided-graph">3.16.1. 882. Reachable Nodes In Subdivided Graph</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation, the problem actually what to know K-min_dist(start, i) for every i, so actually a dij problem.</p>
<p><strong>Note</strong>: that it is equavalent to use a max queue and store K-min_dist, one can prove that the poping sequence is the same as min queue or directly prove this problem as the same as Dij.</p></li>
</ul></li>
</ul>
<h3 id="word-search-ii">3.16.2. 212. Word Search II</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: this is a typical dfs problem where we can use trie to expedite the process. tree problem</li>
</ul>
<p><strong>Note</strong>: For Trie, 26 pointers to point the sub-strings and a bool leaf to indicate whether the current node is a leaf (i.e. a string in words) and also idx is used to save the index of words for the current node. For DFS, just check if the current position is visited before (board[i][j]=='X'), if so, return, check if there is a string with such prefix (nullptr == root-&gt;children[words[idx][pos]-'a']), if not, return; otherwise, check if the current searched string is a leaf of the trie (a string in words), if so, save it to res and set leaf of the trie node to false to indicate such string is already found. At last, move to its neighbors to continue the search. Remember to recover the char [i][j] at the end.</p></li>
<li><p>careful</p>
<ul>
<li>be sure to use &amp; when necessary! since not using &amp; will copy this fucker and slow the code down!!</li>
</ul></li>
</ul>
<h3 id="evaluate-divisionfloyd">3.16.3. 399. Evaluate Division(floyd)</h3>
<ul>
<li>key
<ul>
<li>observation: variation of floyd=&gt;</li>
</ul></li>
</ul>
<h3 id="sort-items-by-groups-respecting-dependenciestopo">3.16.4. 1203. Sort Items by Groups Respecting Dependencies(topo)</h3>
<ul>
<li>key
<ul>
<li>observation: topo sorts</li>
</ul></li>
</ul>
<h3 id="flower-planting-with-no-adjacent">3.16.5. 1042. Flower Planting With No Adjacent</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: since only 3 edges are connected so the choose is easy, anything is ok</p></li>
<li><p>optimization: if more than 3 edges are connected, sort the order of which gardens to plant flowers in by the number of edges it is connected to:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sortedEdges = sorted(((len(g[x]), x) <span class="keyword">for</span> x <span class="keyword">in</span> g), reverse = <span class="literal">True</span>).</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="find-eventual-safe-states-find-circles">3.16.6. 802. Find Eventual Safe States (find circles)</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: need to find circles. 3 conditions below</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Untitled-22.jpg" alt="Untitled-22"><figcaption>Untitled-22</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="is-graph-bipartite">3.16.7. 785. Is Graph Bipartite</h3>
<ul>
<li>key
<ul>
<li>observation: separate the problem into k components, and do dfs on each of them.</li>
</ul></li>
</ul>
<h3 id="minimum-height-trees">3.16.8. 310. Minimum Height Trees</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(n)\)</span> observation: do bfs on leaves, and the last that survives are the possible roots. So basically in the end, the nodes in the queue would be connected to no other nodes but each other.</p>
<p><strong>Lemma</strong>: there can't exists more than 2 on the last layer, so the it's either 1 or 2, so we can output the nodes with degrees = 0.</p></li>
<li><p>optimization: you can either use visited set(which is slow) / remove the edge when used.</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Untitled-28.jpg" alt="Untitled-28"><figcaption>Untitled-28</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="divide-concur-basic-bottom-up">3.17. divide &amp; concur (basic bottom-up)</h2>
<h3 id="findi-j-findi-1-j-findi-j1">3.17.1. 240. find(i, j) = find(i-1, j) || find(i, j+1)</h3>
<ul>
<li>key
<ul>
<li>observation: find propagation function between problem &amp; subproblems</li>
</ul></li>
</ul>
<h3 id="kth-largest-element-in-an-array">3.17.2. 215. Kth Largest Element in an Array</h3>
<ul>
<li>key
<ul>
<li><p>observation: we can sub this problem by =&gt; if we need to find the kth largest the problem becomes sort(k) , we know that we have all k-1 smaller element on its left ( e,g. 5 6 4(*) 3 1 2 if we want the 3rd largest) so we don't acctually care about the order of left of 4. so the subproblem can be sort(k-1), k-2 ... 1 largest. The hard point is that we don't know the kth partition pivix, so we can only guess the pixiv, for example if we choose the last element of array, we can use std::partition to solve the subproblem. so we random solve $sort(m) =&gt; sort((m-1)/2) or sort(random(n&lt;n)) $</p></li>
<li><p>alternative: insert heap</p></li>
</ul></li>
</ul>
<h3 id="beautiful-array">3.17.3. 932 beautiful array</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: from odd &amp; . =&gt; <span class="math inline">\(array(n) = (array((n+1)/2)*2-1) +(array(n/2)*2)\)</span></li>
</ul></li>
</ul>
<h3 id="count-of-range-sum">3.17.4. Count of Range Sum</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: when left of merge_vector and right of merge_vector is sorted will help with the searching like in this case is nums[i] - nums[j], sorted left and sorted right will only cost O(n) to merge search.</p>
<p>range sum =&gt; prefix[i] - prefix[j]. Think about merge and sort, we can split the prefix into 2 =&gt; [13,21,3,123,] [1,312,3,123,12,] and if we computed count(left) + count(right) + count(in between), it is O(n2), however if we sort the array along =&gt; O(nlogn + n(merge)) . done. same if we split into [n-i] [i], we use insert sort instead of merge sort. =&gt; O(nlogn + n2)</p></li>
</ul></li>
<li><p>careful</p>
<ul>
<li><p>== (?0:1) add parathesis</p></li>
<li><p>notice when empty</p></li>
</ul></li>
</ul>
<h3 id="reverse-pairs">3.17.5. 493. Reverse Pairs</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation1: <span class="math inline">\(rev(i) = res(i-1) + c\)</span>, tried red-black tree =&gt; O(n * n)(worst case) but TLE. or we can try BIT whose worst case is O(n logn) , by using BIT we insert the index of element and sum of BIT become the num of element satisfying the condition.</p></li>
<li><p>observation2: <span class="math inline">\(rev(i) = rev(i/2)+rev(i/2+1)+c\)</span>, by this propagation equation we can sort the array along the subproblem, by sorting the array we can use 2 pointer trick to make it linear =&gt; O(n)</p></li>
</ul></li>
</ul>
<h3 id="permutation-sequence">3.17.6. 60. Permutation Sequence</h3>
<ul>
<li>key
<ul>
<li>observation: add k/(n-1)! th element to the front then it becomes a subpermutation without that element, use an array to store all usable elements.</li>
</ul></li>
</ul>
<h3 id="section-2">3.17.7. </h3>
<h2 id="dynamic-programming-1">3.18. dynamic programming</h2>
<h3 id="sumi-j">3.18.1. 303 sum(i, j)</h3>
<ul>
<li>key
<ul>
<li>observation: use down-top &amp; subproblem: sum(i, j) = sums[j] - sums[i], which means n subproblems. note that: dynamic programming may seem not necessary in this senecio, but dp not only save time on 1 time calling, but saving time on multiply calling as well;</li>
<li>alternative: top-down is not neccsary in this.</li>
</ul></li>
</ul>
<h3 id="maxsolutioni">3.18.2. 198 maxsolution(i)</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: use down-top: robs[i] = max(robs[i-1], robs[i-2] + nums[i-1]);</p></li>
<li><p>alternative: can use more variables (2 pointer ) to record delay : [i-2] and [i-1] (not preferred)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ninc = ex + it;</span><br><span class="line">ex = max(inc, ex);</span><br><span class="line">inc = ninc;</span><br></pre></td></tr></table></figure>
<p>is same as</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">robs[i] = max(robs[i-1], robs[i-2] + nums[i-1]);</span><br></pre></td></tr></table></figure></li>
<li><p>alternitive: tried top-down, so fucking memory-consuming and hard to write, make sure that use smallest data as possible, such as &lt;vector, i&gt; can replace <vector cut to i></vector></p></li>
</ul></li>
<li><p>carefull</p>
<ul>
<li><p>int<a href="#section-3"></a> are init as 0; char are init as unknown. memset(robs,-1,sizeof(robs));</p></li>
<li><p>remember that the index difference (offset = 1) of array<a href="#section-3"></a> and memory maxsolution(i)</p></li>
</ul></li>
</ul>
<h3 id="maxsumi-j">3.18.3. 53. maxsum(i, j)</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: use subproblem: maxsum(i, j) = max(local(0~i)) local(i) = max(local[i-1], local[i-1]+xx), n subproblems, o(n).</p></li>
<li><p>equivalent implement: math trick: think about the features about problem before solving it: in this problem, you can see if optimal = sum(i, j) that we must have every sum(i-k, i) &lt; 0. therefore our priority is to set the starting point at i and it will turn to a O(n). so we only have to set sum = 0 if we sum &lt;0 (which means start over from a new point) then it suffices to prove that the algorithm will let us start at i which yields the optimal.</p></li>
<li><p>more advaned algorithm: use <span class="math inline">\(ms=max(sum(j)-sum(i))\)</span> so we save the $min(k) k&lt;i $ during the loop and it's done.... so easy. this solution have nothing to do with dp.</p></li>
</ul></li>
</ul>
<h3 id="maxi-j">3.18.4. 392. max(i, j)</h3>
<ul>
<li>key:
<ul>
<li>obervation: can't use subproblem, so it have to be a 2-dim array</li>
<li>improve: use space saving tech!! 2-dim -&gt; 2*1-dim</li>
</ul></li>
<li>careful:
<ul>
<li>i = 0/ j=0</li>
<li>copy 2 array &amp; conditions</li>
<li>the change of prop equation</li>
<li>no assignment in if.</li>
</ul></li>
</ul>
<h3 id="maxi">3.18.5. 91 max(i)</h3>
<ul>
<li><p>key:</p></li>
<li><p>obervation: consider all possible outcomes</p></li>
<li><p>carefull:</p>
<ul>
<li>&quot;0&quot; and 0</li>
</ul></li>
</ul>
<h3 id="continuous-subarray-sum">3.18.6. 523. Continuous Subarray Sum</h3>
<ul>
<li>key:
<ul>
<li>obervation: boring &amp; tedious</li>
</ul></li>
</ul>
<h3 id="k-concatenation-maximum-sum">3.18.7. 1191 K-Concatenation Maximum Sum</h3>
<ul>
<li><p>key:</p>
<ul>
<li>obervation: observe this string first. 从大到小思考，划清界限：比如在这里设用到i个方块里面的数字。那么i=0到k，k到2的情况都是等价的，可以证明他们必然终止于同一点。所以只需要考虑max1, max2, max2+(k-2)<em>sum,然后max2 &gt;= max1, 所以解为max(m2, m2+(k-2) </em> sum)。这道题的动态规划比较隐蔽，而且没有复杂的规约式子,maxj = max(j-1) + max(0, sum). 所以需要好好思考。</li>
</ul></li>
</ul>
<h3 id="freedom-trail">3.18.8. 514. Freedom Trail</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: separate the problem to sub[i-1]+problem[from i-1 to i] = sub[i]. matrix[keysize][ring size], and matrix[i][j] means that key &lt;=i 's smallest route on ring[j].</p>
<p>$$ <span class="math display">\[\begin{equation}
matrix[i][j]=
\left\{  
\begin{array}{**lr**}  
min_k(matrix[i-1][k] + distance[k\to j]) &amp; \text{if k is not empty}  \\  

INT\_MAX &amp;  \text{if ring[j] != key[i]}  
\end{array}  
\right.  
\end{equation}\]</span> $$</p></li>
</ul></li>
<li><p>carefull</p>
<ul>
<li><p>init size of vector</p></li>
<li><p>iteration i &amp; j don't mess them up</p></li>
<li><p>don't mess up the parameters</p></li>
</ul></li>
</ul>
<h3 id="valid-permutations-for-di-sequence">3.18.9. 903. Valid Permutations for DI Sequence</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: separate the problem to sub[i-1] + xxx = sub[i]</p>
<p>（1） we think about this problem from i-1 to i: that if we set DL, how about DLD?</p>
<p>（2） we think of matrix[i][j] means the i th element is the jth largest among all string, then we can use DL to indicate the [i+1][j] from ith, that if D=&gt; we add matrixi[j] to all matrix i+1[&lt;j], but here's the problem we don't have the ability to solve the duplicate issue.</p>
<p>（3） so we improve 1) by setting j = sizeofstring+1-i and contains the jth largest of the rest of string. the reason we do this is we don't have to worry about duplicate, since the i and j suffices m[i][j] = jth ... = <strong>sum of all m[i-1]</strong> ; and the final matrix[size][1] = size*(size-1)*(size-2) ... = all possible, so we can choose who to pick from level i-1 only by &quot;DL&quot; string. And we can see that setting in 1) do not satisty this sum of propagation which means we have to choose who to sum up not only from the string but also considering whether there is duplicated element, which is a big problem.</p>
<p><span class="math display">\[
\begin{equation}  
matrix[i][j]=\left\{  
             \begin{array}{**lr**}  
             \sum_{k=j+1}^{size+2-i} matrix[i-1][k] &amp; \text{if string[i-2]=&#39;D&#39;}  \\  
             \sum_{k=1}^{j} matrix[i-1][k] &amp;  \text{else}    
             \end{array}  
\right.  
\end{equation}
\]</span></p></li>
<li><p>algorithm2:</p>
<p>（0） we get 0~i-1 permutation(i-1 substring), we do sth to get i permutation(i substring)</p>
<p>let's say <code>dp[i][j]</code> represents the number of permutation of number <code>0, 1, ... , i</code> which ends with <code>j</code>. Also, it represents the answer of <code>s.substring(0, i)</code> which ends with <code>j</code> . this actually stems from the brilliant idea that we first use 0 to i-1 permutation and add 1 to those &gt;= j where j is the the end of i permutation. This works because the only cases where +1 will destroy the order is when j = k+1 and permu(i) - permu(k) = +-1 (e.g. 23) and by adding &gt;= j, the order of 23 will not change, therefore it's safe to add the 1 to i-1 permutation and get i permutation. therefore we have the equation below <span class="math display">\[
dp[i][j]=\left\{  
               \begin{array}{**lr**}  
              sum(dp[i - 1][0], dp[i - 1][1], ... , dp[i - 1][j - 1]). &amp; \text{s.charAt(i - 1) == &#39;I&#39;: I}\\
                        sum(dp[i - 1][j], dp[i - 1][j + 1], ... , dp[i - 1][i - 1]). &amp; \text{s.charAt(i - 1) == &#39;D&#39;:} 
               \end{array}  
  \right.
\]</span> （1） the above 2 algorithms stems from the same D&amp;C intuition, but they construct by different ways algorithm1 construct a string by directly saying that what should be the end of the first elements of the final string. algorithm2 construct a string with a subset of permutation however following the same rule and construct a larger string by that. algorithm1 is more intuitive, algorithm2 takes more time to think about and prove it's correctness.</p></li>
</ul></li>
</ul>
<h3 id="burst-balloons">3.18.10. 312. Burst Balloons</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation : i-1 and i doesn't work. start:i-i i i+1:end work in this case</p>
<ol type="1">
<li><p>set matrix[i][j] = from [i to j] optimal sequence when i-1 and j+1 are not bursted yet.</p></li>
<li><p>we can get the following equation <span class="math display">\[
d[i][j] = \max \limits_{k \in[1,n-2]} d[i][k-1] + d[k+1][j] +s[i]s[k]s[j]
\]</span> <strong>Note</strong>: this seems quite easy but it's not intuitive, in order to get this equation we have to assume k is the last to burst. the naive thought would be s[i-1] =&gt; s[i] but this is too complicated, so [i][j-1] and [j][i] will it work? if j-1 and j is connected, this is fucked up since [i:j-1] is affected by [j:end], to make separate the problem , we have to make them independent, which means [i:j-1] have to be secured by a fixed j that have nothing to do with the right part which leaves us no choice and have to choose j as a fixed ballon. In the mean time, j has to be fixed since the right of j requires the same as well. So j is fixed all the time which means it is the last one to burst, only by this assumption, we can separate the problem into 2 independent subproblems. And we have to keep in mind that we have many choices as fixed j, we choose the maximum.</p></li>
</ol></li>
</ul></li>
</ul>
<h3 id="wildcard-matching">3.18.11. 44 wildcard matching</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: <code>dp[i][j] means validity with [0,i] &amp; [0,j]</code> , and that we can sub this problem using a 2 pointer, mind that below is a simplified version of dp, the original dp of condition2 is dp[i][j] = OR_all_i-k,j , since i-1,j itself equals OR_all_i-1-k,j, we only need to OR dp_i-1,j =&gt; simplifies the problem <span class="math display">\[
\begin{equation}  
dp[i][j]=\left\{  
                 \begin{array}{**lr**}  
    dp[i-1][j-1] &amp; \text{if s[i]==p[j] or p[j] ==&#39;?&#39;}  \\  
    dp[i-1][j] || dp[i][j-1] &amp;  \text{if p[j] == &#39;*&#39;}    \\
    false &amp; \text{else}
                 \end{array}  
    \right.  
    \end{equation}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def isMatch(self, s, p):</span><br><span class="line">        dp = [[False <span class="keyword">for</span> _ in range(len(p)+<span class="number">1</span>)] <span class="keyword">for</span> i in range(len(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = True</span><br><span class="line">        <span class="keyword">for</span> j in range(<span class="number">1</span>, len(p)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[j<span class="number">-1</span>] != <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = True</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j in range(<span class="number">1</span>, len(p)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j<span class="number">-1</span>] in &#123;s[i<span class="number">-1</span>], <span class="string">'?'</span>&#125;:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                elif p[j<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] <span class="keyword">or</span> dp[i][j<span class="number">-1</span>]</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>​</p>
<h3 id="regular-expression-matching">3.18.12. 10 Regular Expression Matching</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation:</p>
<p>We define <code>dp[i][j]</code> to be <code>true</code> if <code>s[0..i]</code> matches <code>p[0..j]</code> and <code>false</code> otherwise. The state equations will be:</p>
<p><span class="math display">\[
\begin{equation}  
dp[i][j]=\left\{  
\begin{array}{**lr**}  
dp[i - 1][j - 1] )&amp;  \text{if(s[i] == p[j] || p[j] == &#39;.&#39;)} \\   
(dp[i - 1][j]\&amp;(s[i] == p[j - 1] || p[j - 1] == &#39;.&#39;)) || dp[i][j-2]&amp; \text{if p[j]=&#39;*&#39;}   \\  
false
\end{array}  
\right.  
\end{equation}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    def isMatch(self, s, p):</span><br><span class="line">        dp = [[False <span class="keyword">for</span> _ in range(len(p)+<span class="number">1</span>)] <span class="keyword">for</span> i in range(len(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = True</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span> i in range(<span class="number">0</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j in range(<span class="number">1</span>, len(p)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">and</span> p[j<span class="number">-1</span>] in &#123;s[i<span class="number">-1</span>], <span class="string">'.'</span>&#125;:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] </span><br><span class="line">                elif p[j<span class="number">-1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-2</span>] <span class="keyword">or</span> (i <span class="keyword">and</span> dp[i<span class="number">-1</span>][j] <span class="keyword">and</span> (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] <span class="keyword">or</span> p[j<span class="number">-2</span>] == <span class="string">'.'</span>))</span><br><span class="line">                    </span><br><span class="line">                <span class="built_in">print</span>(i, j, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="word-break-ii">3.18.13. 140. Word Break II</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(2^n )\)</span> observation: DFS is obvious, level_i = fixed first i words. but we can see that there are overlapping problems, so we can use DP to accelerate process.</p></li>
<li><p><span class="math inline">\(O(2^ n)\)</span> algorithm2: top down DP, top town DP is most similar to DFS, but to use a map(prefer unordered for performance purposes) saving the results will make it faster.</p></li>
<li><p><span class="math inline">\(O(2^n)\)</span> algorithm3: bottom up DP, bottom up DP in this problem is not preferred since we have propagation function below, use <code>DP[i] to indicate results for [0,i]</code> : <span class="math display">\[
DP[i] = combine(DP[j],s[j+1:i]) \text{if s[j+1:i] $ \in$ wordset }
\]</span> so implement this b-u DP, we'll have to find all possible problems.</p></li>
</ul></li>
</ul>
<h3 id="stickers-to-spell-word">3.18.14. 691. Stickers to Spell Word</h3>
<ul>
<li><p>key :</p>
<ul>
<li><p><span class="math inline">\(O(2^{s(target)}*s(sticker))\)</span> observation: bottom-up so fucking hard! observe this problem, you can the following dp equation: if <code>DP[i] indicate minimum of the ith permutation subset</code> we can see that: since k&lt;i, so every j&gt;i, DP[j] depends on DP[i], so we acctually can iterate from i = 0 =&gt; <span class="math inline">\(2^n\)</span>, after step i, DP[i+1] is uptodate, so we can derive from here that DP[m-1] is uptodate. <span class="math display">\[
\begin{equation}  
dp[i]=\left\{  
             \begin{array}{**lr**}  
 (DP[k]+1)  &amp; \text{k $\in$ set is possible position k union sticker=i}  \\  
INTMAX&amp;  \text{if set_size=0}    
             \end{array}  
\right.  
\end{equation}
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = target.<span class="built_in">size</span>(), m = <span class="number">1</span> &lt;&lt; n; <span class="comment">// if target has n chars, there will be m=2^n-1 subset of characters in target</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;uint&gt; dp(m, <span class="number">-1</span>); <span class="comment">// use index 0 - 2^n-1 as bitmaps to represent each subset of all chars of target</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// first thing we know is : dp[empty set] requires 0 stickers,</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123; <span class="comment">// for every subset i, start from 00000...(emptyset) to 111111...(the target)</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">string</span>&amp; s : stickers) &#123; <span class="comment">// try use each sticker as an char provider to populate a super-set of i,</span></span><br><span class="line">                <span class="keyword">int</span> sup = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123; <span class="comment">// to do that, for each char in the sticker, </span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (target[r] == c &amp;&amp; !((sup &gt;&gt; r) &amp; <span class="number">1</span>)) &#123; <span class="comment">// try apply it on a missing char in the subset of target</span></span><br><span class="line">                            sup |= <span class="number">1</span> &lt;&lt; r;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">// after you apply all possible chars in a sticker, you get an superset that take 1 extra sticker than subset</span></span><br><span class="line">               <span class="comment">// would take, so you can try to update the superset's minsticker number with dp[sub]+1;</span></span><br><span class="line">                dp[sup] = <span class="built_in">min</span>(dp[sup], dp[i] + <span class="number">1</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>]; <span class="comment">// and the ultimate result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>: the hard part of this bottom-up implementation is that you don't know the exact thing to update=&gt; but the algorithm implies that after ith time, DP[i+1] is updated, so you can see that is the hard part.</p></li>
</ul></li>
</ul>
<p>​</p>
<ul>
<li><p>algorithm2: top-down</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStickers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; stickers, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = stickers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="comment">// count characters a-z for each sticker </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c:stickers[i]) mp[i][c-<span class="string">'a'</span>]++;</span><br><span class="line">        dp[<span class="string">""</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(dp, mp, target);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; dp, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mp, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp.count(target)) <span class="keyword">return</span> dp[target];</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX, n = mp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tar(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c:target) tar[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="comment">// try every sticker</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// optimization</span></span><br><span class="line">            <span class="keyword">if</span> (mp[i][target[<span class="number">0</span>]-<span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="comment">// apply a sticker on every character a-z</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) </span><br><span class="line">                <span class="keyword">if</span> (tar[j]-mp[i][j] &gt; <span class="number">0</span>) s += <span class="built_in">string</span>(tar[j]-mp[i][j], <span class="string">'a'</span>+j);</span><br><span class="line">            <span class="keyword">int</span> tmp = helper(dp, mp, s);</span><br><span class="line">            <span class="keyword">if</span> (tmp!= <span class="number">-1</span>) ans = <span class="built_in">min</span>(ans, <span class="number">1</span>+tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[target] = ans == INT_MAX? <span class="number">-1</span>:ans;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="odd-even-jump-2">3.18.15. 975. Odd Even Jump</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation dp_h[i] = success or not if go higher at i</p>
<p><span class="math display">\[
\begin{equation}   
res= \sum_{i=1}^{n}dp_h[i] \\
dp_h[i]=dp_l[nexthigher(i)] \\
dp_l[i]=dp_h[nextlower(i)]
\end{equation}
\]</span></p>
<p><strong>Note</strong>: that dp[i] depends on higher i so, we go from higher to lower .</p></li>
</ul></li>
</ul>
<h3 id="minimum-number-of-refueling-stops">3.18.16. 871. Minimum Number of Refueling Stops</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: <code>dp[t]</code> means the furthest distance that we can get with <code>t</code> times of refueling.</p>
<p>So for every station <code>s[i]</code>,if the current distance <code>dp[t] &gt;= s[i][0]</code>, we can refuel: <code>dp[t + 1] = max(dp[t + 1], dp[t] + s[i][1])</code> In the end, we'll return the first <code>t</code> with <code>dp[i] &gt;= target</code>, otherwise we'll return -1. <span class="math display">\[
dp[i][j]= max(dp[i][j-1],dp[i-1][j-1]+fuel[j]) \text{   if dis[j]&lt;=dp[i]}
\]</span> <strong>Note</strong>: that we actually go station by station, at each station we update the all possible largest outcome by taking all -&gt; none. At a new station, largest dp[i][j] is either the i largest of 1:j-1 or i-1 largest of 1:j-1 and take station j. by seeing that dp[i][j] is only concern with 2 element on the previous row, we can reduce the matrix to an row and set an update sequence to make sure it is equivalent to matrix.</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_3698.JPG" alt="IMG_3698"><figcaption>IMG_3698</figcaption>
</figure></li>
</ul></li>
<li><p>careful</p>
<ul>
<li>don't use auto=size()</li>
</ul></li>
</ul>
<h3 id="race-car">3.18.17. 818. Race Car</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: <code>dp[i] means the least number of target i</code> <span class="math display">\[
dp[i] = min(dp[2^n-1-i] + steps, dp[i-2 ^{n-1}+2 ^{m}]+steps.  \text{   n=floor(log2(i))}
\]</span> ok, so we go like [AAAAR][AAAR] and number of A could be zero so we include the double turning situation. the nA could be anything from <span class="math inline">\(2 ^{m}-1\)</span>, we have to do trimming. So the <strong>Lemma</strong> here is for i, it has to include either $2 ^{n}-1 $ or <span class="math inline">\(2 ^{n-1}-1\)</span>, the former is easy to prove, however to prove the latter is hard.</p>
<p><strong>Note</strong>: The observation is that for i that $ 2 ^{m-1}-1 +2^{m}-1 +1i 2 ^{m}-1+2 ^{m+1}-1$ , <span class="math inline">\(2 ^{m}-1\)</span> will always appear on the optimal answer. So you can see it's either the 2 options given above (e.g. for i &gt; 2**4 and i &lt; 2^5, it's either 15 or 31)</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_6261.JPG" alt="IMG_6261"><figcaption>IMG_6261</figcaption>
</figure>
<p><strong>Note</strong>: even if can't come up with this optimization, the obvious thoughts will work =&gt; go F from 0 to n-1 and go back for less.</p></li>
</ul></li>
<li>careful
<ul>
<li>(1&lt;&lt;(sss))</li>
<li>set the first dp not min, if you can't assign global vector. or you can assign it in main.</li>
</ul></li>
</ul>
<h3 id="course-schedule-iii">3.18.18. 630. Course Schedule III</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: same as 871.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scheduleCourse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; courses)</span> </span>&#123;</span><br><span class="line">        sort(courses.<span class="built_in">begin</span>(), courses.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;<span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];&#125;);</span><br><span class="line">        <span class="keyword">int</span> n = courses.<span class="built_in">size</span>(); <span class="built_in">vector</span>&lt;<span class="keyword">int64_t</span>&gt;dp(n, INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;dp[j] = courses[<span class="number">0</span>][<span class="number">0</span>]&lt;=courses[<span class="number">0</span>][<span class="number">1</span>]?courses[<span class="number">0</span>][<span class="number">0</span>]:INT_MAX; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>((j==<span class="number">0</span>?<span class="number">0</span>:dp[j<span class="number">-1</span>])+courses[i][<span class="number">0</span>]&lt;=courses[i][<span class="number">1</span>])&#123;dp[j] = <span class="built_in">min</span>(dp[j], (j==<span class="number">0</span>?<span class="number">0</span>:dp[j<span class="number">-1</span>])+courses[i][<span class="number">0</span>]);&#125;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="string">" "</span>&lt;&lt; j &lt;&lt;<span class="string">" "</span>&lt;&lt; dp[j]   &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>; <span class="keyword">for</span>(; i&lt;=n<span class="number">-1</span>; i++) <span class="keyword">if</span>(dp[i]==INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>careful</p>
<ul>
<li>((1==?):0:1)</li>
</ul></li>
</ul>
<h3 id="jump-game-ii">3.18.19. Jump Game II</h3>
<ul>
<li>key
<ul>
<li>observation: same as 871</li>
</ul></li>
</ul>
<h3 id="maximum-profit-in-job-scheduling">3.18.20. 1235. Maximum Profit in Job Scheduling</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation O(n3): <span class="math display">\[
DP[i][j] = DP[q&lt;i][j-1]...
\]</span></li>
</ul></li>
<li><p>algorithm2 O(n2): <code>DP[i] means DP max taking i</code> <span class="math display">\[
  DP[i] = max(DP[all_qfits&lt;i]+...)
  \]</span></p>
<ul>
<li><p>algorithm1 O(n2 or n): <code>DP[i] means DP max until i</code> <span class="math display">\[
DP[i] = max(DP[first_q fits &lt;i]+...)
\]</span> <strong>Note</strong>: the opt come up like this: we only need max from all_qfits&lt;i so basically we only need to keep max to DP[first_qfits], so meet the demands and cut the unless crap.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">jobScheduling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> sz = startTime.<span class="built_in">size</span>();</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; index(sz, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sz<span class="number">-1</span>; i++) &#123;index[i][<span class="number">0</span>]=endTime[i], index[i][<span class="number">1</span>]=startTime[i], index[i][<span class="number">2</span>]=profit[i];&#125; sort(index.<span class="built_in">begin</span>(), index.<span class="built_in">end</span>(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];&#125;);</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(sz+<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> ma = INT_MIN;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=sz; i++, j=i<span class="number">-1</span>)&#123;</span><br><span class="line">              dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">              <span class="keyword">while</span>(j&gt;=<span class="number">1</span> &amp;&amp; index[j<span class="number">-1</span>][<span class="number">0</span>]&gt;index[i<span class="number">-1</span>][<span class="number">1</span>]) j--;</span><br><span class="line">              dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+index[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> dp[sz];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="partition-array-for-maximum-sum">3.18.21. 1043. Partition Array for Maximum Sum</h3></li>
<li><p>key:</p>
<ul>
<li><span class="math inline">\(O(nk)\)</span> observation: <code>dp[i] is the largest from 0 -&gt; i-1 &amp; separate i-1|i</code> <span class="math display">\[
 dp[i] = max(dp[i], (i &gt;= k ? dp[i - k] : 0) + curMax * k);
\]</span> <img src="/2019/12/03/datastructure-algorithm/Untitled-18.jpg" alt="Untitled-18"></li>
</ul></li>
</ul>
<h3 id="best-time-to-buy-and-sell-stock-iii">3.18.22. Best Time to Buy and Sell Stock III</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: separate the problem to <code>max(DP_1[i] + DP_2[i+1])</code> and <span class="math display">\[
DP_1[i].second = max(DP_1[i-1].second, A[i]-DP_1[i-1].first)
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; left, right;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sz = prices.<span class="built_in">size</span>(); <span class="keyword">if</span>(!sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        left.resize(sz), right.resize(sz); left[<span class="number">0</span>] = &#123;prices[<span class="number">0</span>], <span class="number">0</span>&#125;; right[sz<span class="number">-1</span>] = &#123;prices[sz<span class="number">-1</span>], <span class="number">0</span>&#125;; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=sz<span class="number">-1</span>; i++)&#123;</span><br><span class="line">            left[i] = &#123;<span class="built_in">min</span>(left[i<span class="number">-1</span>].first, prices[i]),</span><br><span class="line">                       <span class="built_in">max</span>(left[i<span class="number">-1</span>].second, prices[i]-left[i<span class="number">-1</span>].first)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=sz<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            right[i] = &#123;<span class="built_in">max</span>(right[i+<span class="number">1</span>].first, prices[i]),</span><br><span class="line">                        <span class="built_in">max</span>(right[i+<span class="number">1</span>].second, right[i+<span class="number">1</span>].first-prices[i])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max_ = INT_MIN; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sz; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> l = (i==<span class="number">0</span>)?<span class="number">0</span>:left[i<span class="number">-1</span>].second; <span class="keyword">auto</span> r = (i==sz)?<span class="number">0</span>:right[i].second;</span><br><span class="line">            max_ = <span class="built_in">max</span>(max_, l+r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>### 689. Maximum Sum of 3 Non-Overlapping Subarrays</p>
<ul>
<li><p>key</p>
<ul>
<li>observation: <span class="math display">\[
dp[i,3] = max(dp[i-1,3] or 0 , dp[i-k,3-1] or 0)
\]</span> <strong>Note</strong>: that the hard part is how to record all 3 indexes. As top-down is too comsuming, bottom up is preferred.</li>
</ul></li>
</ul>
<h2 id="depth-first-search-1">3.19. depth first search</h2>
<ul>
<li>排列问题 Permutations。第 46 题，第 47 题。第 60 题，第 526 题，第 996 题。</li>
<li>组合问题 Combination。第 39 题，第 40 题，第 77 题，第 216 题。</li>
<li>排列和组合杂交问题。第 1079 题。</li>
<li>N 皇后终极解法(二进制解法)。第 51 题，第 52 题。</li>
<li><p>数独问题。第 37 题。</p></li>
<li>四个方向搜索。第 79 题，第 212 题，第 980 题。</li>
<li>子集合问题。第 78 题，第 90 题。</li>
<li><p>Trie。第 208 题，第 211 题。</p></li>
<li>BFS 优化。第 126 题，第 127 题。</li>
<li><p>DFS 模板。(只是一个例子，不对应任何题)</p></li>
</ul>
<h3 id="addopeartion">3.19.1. 282 addopeartion</h3>
<ul>
<li>key:
<ul>
<li><p>observation: is easy =&gt; 4^n algorithm, no other way?</p>
<p>=&gt; cur[i+?] = cur[i] +-* cur[i:r]; and be careful that when cur[i:r] start with 0 such as 01 =&gt; it can't be treated as a number, so we skip it .</p></li>
</ul></li>
</ul>
<h3 id="count-of-smaller-numbers-after-self-from-dc-1">3.19.2. 315. Count of Smaller Numbers After Self (from D&amp;C)</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: the observation is not intuitive!!!:((((</p>
<p>=&gt; cur[i, j] = cur[i, mid] + cur[mid+1, j] + between(left and right）and if we could somehow sort this left &amp; right, the between procedure is O(n)， so, merge sort.</p></li>
<li><p>algorithm2:</p>
<p>=&gt; cur[i] = smaller[i+1:end] =&gt; insert cur[i] into [i+1:end] and see how many is smaller.(this is usage of BST)</p></li>
</ul></li>
<li><p>careful</p>
<ul>
<li><p>empty!!</p></li>
<li><p>INT_MIN not -1</p></li>
</ul></li>
</ul>
<h3 id="freedom-trail-1">3.19.3. 514. Freedom Trail</h3>
<ul>
<li>key:
<ul>
<li>observation: separate the problem to [0: i-1] + from[i-1 to i] + [i: size-1]</li>
</ul></li>
</ul>
<h3 id="binary-watch">3.19.4. 401 Binary Watch</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: we can depth first search =&gt; by setting the same level as same number of bits. and add 1 to it until gg.</li>
</ul></li>
</ul>
<h3 id="different-ways-to-add-parentheses">3.19.5. Different Ways to Add Parentheses</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: suppose we have a final signal <em>/-/+ (e.g. (3-1) </em> (2-3) *is the final) and we can separate the equation to 2 part =&gt; <span class="math inline">\(sum(1, sizeof(n)) =(sum(1, i) */-/+ sum(i+1, sizeof(n))) \text{ for i in [1, sizeof(n) -1]}\)</span>. so this becomes easy.</li>
</ul></li>
</ul>
<h3 id="upper-lower-letters">3.19.6. upper lower letters</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: i th level is the string with ith first elements dealt with.</li>
</ul></li>
</ul>
<h3 id="restore-ip-addresses">3.19.7. 93. Restore IP Addresses</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: ith level is the left dots to put , i = 1,2,3,4, so conditions on i =1 .</li>
</ul></li>
</ul>
<h3 id="additive-number">3.19.8. 306 additive number</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: 2 pointer exhaustion, DFS, the hard part is the margin condition</li>
<li>algorithm2: or you can optimize it by using 3 arrays/bitset to indicate if col/skewedleft/skewed right is full.</li>
</ul></li>
<li><p>careful</p>
<ul>
<li>always careful with the margin especially when dealing with arrays!!!</li>
</ul></li>
</ul>
<h3 id="n-queens">3.19.9. 51. N-Queens</h3>
<ul>
<li>key: track this shit</li>
<li>careful:
<ul>
<li>with the bit manipulation</li>
</ul></li>
</ul>
<h3 id="permutations-ii">3.19.10. 47. Permutations II</h3>
<ul>
<li>key: ...ez</li>
</ul>
<h3 id="gray-code">3.19.11. 89. Gray Code</h3>
<ul>
<li><p>key: ...ez</p></li>
<li><p>careful:</p>
<ul>
<li>conditions when we find and cut all other loops.</li>
</ul></li>
</ul>
<h3 id="palindrome-partitioning">3.19.12. 131. Palindrome Partitioning</h3>
<ul>
<li>key: the same level means the number of dots in between</li>
</ul>
<h3 id="letter-combinations-of-a-phone-number">3.19.13. 17. Letter Combinations of a Phone Number</h3>
<ul>
<li>key; the same level means the number dealt with</li>
<li>careful
<ul>
<li>empty input</li>
</ul></li>
</ul>
<h3 id="word-ladder-ii">3.19.14. 126. Word Ladder II</h3>
<ul>
<li>key; same level means the number of findings</li>
<li>careful
<ul>
<li><p>auto a = vector<int> do not necessaily copy ???</int></p></li>
<li><p>reserve carefully or always puck back</p></li>
</ul></li>
</ul>
<h3 id="wildcard-matching-1">3.19.15. 44. Wildcard Matching</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: if the previous <em>(say i-1 th ) is set, and we meet the ith </em>, then if * doesn't meet demands, then we don't need to go back to i-1. this can be proved by constract. so we use a greedy DFS(add trimming) to solve this.</p></li>
<li><p>algorithm2: the above algorithm can be implemented in iteration, we have the following 5 conditions:</p>
<ol type="1">
<li><p>if s==p or p =='?', we move +1</p></li>
<li><p>if p=='*', we record/update the position now for future usage</p></li>
<li><p>if s!=p</p></li>
</ol>
<p>(3.1) if we met * before, go back</p>
<p>(3.2) if we haven't, return false.</p>
<ol start="4" type="1">
<li><p>if p is empty, return true.</p></li>
<li><p>if s is empty (out of while),</p></li>
</ol>
<p>(5.1) if p consist only of &quot;*&quot;, return true.</p>
<p>(5.2) if not, return false.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> sp = s.<span class="built_in">begin</span>(), pp = p.<span class="built_in">begin</span>(), spp = s.<span class="built_in">end</span>()+<span class="number">1</span>, ppp = p.<span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">while</span> (sp != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.substr(sp-s.<span class="built_in">begin</span>()) &lt;&lt;<span class="string">" "</span>&lt;&lt;p.substr(pp-p.<span class="built_in">begin</span>())&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (*sp==*pp || *pp==<span class="string">'?'</span>) &#123;sp++; pp++;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*pp == <span class="string">'*'</span>) &#123;spp = sp+<span class="number">1</span>; ppp = ++pp;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (spp != s.<span class="built_in">end</span>()+<span class="number">1</span>) &#123;sp = spp++; pp = ppp;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (*pp == <span class="string">'*'</span>) pp++;</span><br><span class="line">  <span class="keyword">if</span> (pp == p.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="sudoku-solver">3.19.16. 37. Sudoku Solver</h3>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(9^n)\)</span> observation: key point of solver is always build the map for searching. We first sort out all [i][j] undetermined elements into an array, level ith means [0,i] number is dealt with. and each node we have 9 options for searching.</li>
</ul></li>
<li>careful
<ul>
<li>return when possible(trimming)</li>
<li>careful with the return conditions</li>
</ul></li>
</ul>
<h3 id="stickers-to-spell-word-1">3.19.17. Stickers to Spell Word</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: is easy, level ith = adding i stickers, use vector&lt;26 ,int &gt; to indicate a word</p></li>
<li><p>algorithm2: improve, the result is like this:[sticker f, c, g, c, d], we want to trim this dfs.</p>
<p>First observation is that it contains duplicate so that we save the fucker. Second observation is that dfs contains unnecessary search branchs where no targets are covered. Third observation is that this dfs do not concern with sequential since it's a set, so we want to trim this fucker by sorting so that it do not contain duplicate, however this is not feasible (such as b, f, g, g or g, b, f, g, they are on different path) SO, we can do by using an alternative method: sorting. but how can we do that? we can sort them on something we already know when we reach the node, in this case, it will be the sequence on covering the target string, note that this does not necessarily trim all duplicate sequences. (if a, b, c / c, a, b all contains target[0], target[1], target[2], then it's a duplicate). so this is a partial soring.</p></li>
<li><p>algorithm3: use full sorting =&gt; can't use DP since it's not fully searched.</p></li>
</ul></li>
</ul>
<h3 id="number-of-squareful-arrays">3.19.18. 996. Number of Squareful Arrays</h3>
<ul>
<li>key
<ul>
<li>observation: DFS</li>
<li>algorithm2: avoid duplicate, on each level =&gt; derive that no same sequence is made</li>
</ul></li>
</ul>
<h3 id="tiling-a-rectangle-with-the-fewest-squares">3.19.19. 1240. Tiling a Rectangle with the Fewest Squares</h3>
<ul>
<li>key
<ul>
<li>observation: use array of height to represent a rectangle, and do DFS</li>
<li>algorithm2: set DFS have duplicates, search from largest =&gt; smallest, (note that we may hve irregular DFS, so the hard part is to determine search sequence). so actually we want the best searching sequence that both contains optimals and eliminate duplicate as much as possible. so we focus on the leftest highest 1x1 square and we can do 1x1,2x2.....min(height,width)x2, this is both full search as well as min branches.</li>
</ul></li>
</ul>
<h3 id="unique-paths-iii">3.19.20. 980. Unique Paths III</h3>
<ul>
<li><p>key is easy DFS+DP</p></li>
<li><p>careful</p>
<ul>
<li><p>with count considering -1</p></li>
<li><p>with DP saving and index restoring</p></li>
</ul></li>
</ul>
<h3 id="decoded-string-at-index">3.19.21. 888. Decoded String at Index</h3>
<ul>
<li><p>key</p>
<ul>
<li>actually a one-way dfs with mod and divide, a math problem basically.</li>
</ul></li>
<li><p>carefull:</p>
<ul>
<li><p>with mod</p></li>
<li><p>with //</p></li>
</ul></li>
</ul>
<h3 id="swim-in-rising-water-1">3.19.22. 778. Swim in Rising Water</h3>
<ul>
<li>key
<ul>
<li>observation: no duplicated path: imagine like fill in all blanks only once. set global trimming. 想象一个树杈，然后每个搜索不会有重复的树杈交叉在一起。之所以可以这么做是因为搜索前面的信息不会影响后面，所以一旦后面搜不到了那就是凉了；其他会交叉的题比如8皇后（前面皇后的位置会影响后面的搜索是否成功），比如找钥匙（前面走的路决定了有多少吧钥匙所以会影响后面）。</li>
</ul></li>
</ul>
<h3 id="maximum-score-words-formed-by-letters">3.19.23. 1255. Maximum Score Words Formed by Letters</h3>
<ul>
<li>key
<ul>
<li>observationO(2^n): dfs</li>
<li>max pruning: branch and bound, prun those <code>curr_score + sum(words_score[i:]) &lt;= self.max_score</code></li>
</ul></li>
<li><p>careful</p>
<ul>
<li>use vector&lt;26&gt; to store set&lt;&gt;</li>
</ul></li>
</ul>
<h3 id="section-3">3.19.24. </h3>
<ul>
<li><p>key: make sure the conditions:</p>
<ul>
<li><p><strong>Note</strong>: that some times conditions are hard to implement in tree because the level structure, use parameters to add additional information.</p>
<p>return value =&gt; node child info: node update</p>
<p>para value =&gt; node parent info: leaf update/ trimming</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">bool</span> have_node, <span class="keyword">bool</span> monitored)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(have_node)&#123;</span><br><span class="line">            <span class="keyword">auto</span> temp_left = dfs(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>), temp_right = dfs(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> temp_left+temp_right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(monitored)&#123;</span><br><span class="line">            <span class="keyword">auto</span> take_none = dfs(root-&gt;left, <span class="number">0</span>, <span class="number">0</span>) + dfs(root-&gt;right, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">auto</span> take_top = <span class="number">1</span> + dfs(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>) + dfs(root-&gt;right, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(take_none, take_top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">auto</span> take_left = dfs(root-&gt;left, <span class="number">1</span>, <span class="number">0</span>) + dfs(root-&gt;right, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> take_right = dfs(root-&gt;left, <span class="number">0</span>, <span class="number">0</span>) + dfs(root-&gt;right, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> take_top = dfs(root-&gt;left, <span class="number">0</span>, <span class="number">1</span>) + dfs(root-&gt;right, <span class="number">0</span>, <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val = <span class="built_in">min</span>(<span class="built_in">min</span>(take_left, take_right), take_top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="maximum-sum-of-3-non-overlapping-subarrays">3.19.25. 689. Maximum Sum of 3 Non-Overlapping Subarrays</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: <span class="math display">\[
dp[i,s] = max(dp[i-1,s+k+\epsilon])
\]</span></li>
</ul></li>
<li><p>observation: using top-down implementation. <span class="math display">\[
  dp[i,s] = max(dp[i,s+1], dp[i-1,s+k])
  \]</span></p></li>
<li><p>careful</p>
<ul>
<li>careful with the return conditions</li>
</ul></li>
</ul>
<h2 id="breadth-first-search-1">3.20. breadth first search</h2>
<h3 id="binary-watch-1">3.20.1. 401 Binary Watch</h3>
<ul>
<li>key
<ul>
<li>observation: we can breadth first search =&gt; by setting the same level as same number of bits.</li>
</ul></li>
</ul>
<h3 id="word-ladder-ii-1">3.20.2. 126. Word Ladder II</h3>
<ul>
<li><p>key:</p>
<ul>
<li>observation is very important in this problem. as you can see why we prefer BFS over DFS.That first we only want the shortest=&gt; that's natural advantage, since it means that depth is fixed and all possible answers appears on the same level that we don't necessarily need to exhaust the tree(DFS on the other hand do not have this advantage). Secondly, on the same level, we can see that we can separate the problem into this: the next steps on next level do not appear on the above levels(why? because you can prove that if it exists on the above level, it is not the shortest anymore), so this feature means we can expedite the BFS search by narrowing down possible next steps.</li>
</ul></li>
</ul>
<h3 id="stickers-to-spell-word-2">3.20.3. 691. Stickers to Spell Word</h3>
<ul>
<li>key
<ul>
<li>BFS is obvious but not necessary, but keep in mind that string matching you can always use int.</li>
</ul></li>
<li><p>careful</p>
<ul>
<li><p>vector&lt;vector{size, vector()}</p></li>
<li><p>don't use auto when vector&lt;vector</p></li>
<li><p>don't copy the whole string/ avoid using vector<bool>, use 2^n-1.</bool></p></li>
</ul></li>
</ul>
<h3 id="shortest-path-to-get-all-keys">3.20.4. 864. Shortest Path to Get All Keys</h3>
<ul>
<li>key
<ul>
<li>BFS through that trimming when no keys are acquired.</li>
</ul></li>
<li>careful
<ul>
<li>C++ map is lousy</li>
<li>bitset.tolong()</li>
</ul></li>
</ul>
<h3 id="smallest-sufficient-team">3.20.5. 1125. Smallest Sufficient Team</h3>
<ul>
<li>key
<ul>
<li>observation: bfs</li>
<li>trimming: since it's bfs, trim those with same level branches.</li>
</ul></li>
<li>careful
<ul>
<li><p>for loop check states!</p></li>
<li><p>1&lt;&lt;i (check for LL!)</p></li>
</ul></li>
</ul>
<h3 id="maximum-width-of-binary">3.20.6. 662. Maximum Width of Binary</h3>
<ul>
<li>careful
<ul>
<li>with the poping operations</li>
<li>with int64 overflow</li>
</ul></li>
</ul>
<h3 id="k-similar-strings">3.20.7. 854. K-Similar Strings</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: that at most n swaps will do. each swap -1/-2</p>
<p><strong>Note</strong>: at each layer fix the first element. this ensures a optimal solution. basically, the swapping tech is to find the maximum island numbers, at each level we open n new branches which is new ways of spliting components. The swapping of fixing the first or not fixing the first is the exact same but opposite sequence.</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/Untitled-4-8376111.jpg" alt="Untitled-4"><figcaption>Untitled-4</figcaption>
</figure></li>
<li><p>optimization: since our goal is to maximize the components, then if we can swap for -2, we stop there. This is optimal because</p></li>
</ul></li>
</ul>
<h3 id="as-far-from-land-as-possible">3.20.8. 1162. As Far from Land as Possible</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(kn^2)\)</span> observation: intuition is go from any point of 0, but it is just way too slow</p></li>
<li><p><span class="math inline">\(O(n^2)\)</span> optimization: go from 1s =&gt;</p></li>
</ul>
<p><img src="/2019/12/03/datastructure-algorithm/image-20200107214608898.png"></p></li>
</ul>
<h2 id="binary-search-1">3.21. binary search</h2>
<h3 id="divide-2-numbers">3.21.1. 29 divide 2 numbers</h3>
<ul>
<li>key
<ul>
<li>observation: the array that numbers m, n can be expressed in binary. and divide can be expressed in binary as well. and we can tell that it is unique. so we try to get the unique result, we can do this by shifting the divider. <span class="math inline">\(2^m*d+2^{m-1}*d+2 ^{m-3}*d\)</span>, and m-3 &lt; m-1 &lt; m， so every coefficient is only 1 and smaller each so we can do shifting trick. The original thought is to get every m individually, and this is the original thought to get m involves binary. so this it actually a 31 binary problem =&gt; 31 O(n) $ $ O(n)</li>
</ul></li>
</ul>
<h3 id="ugly-number">3.21.2. 1201 Ugly Number</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: that we can easily compute $f(n)=_{i=1}^{n}I(i ) $, this is how we get the solution: that from max to 1, we find f(k) = n.</li>
</ul></li>
<li><p>careful:</p>
<ul>
<li><p>gcd(a, c, d) = gcd(a, gcd(c, d)) for gcd(a, c, d) <span class="math inline">\(\in\)</span> gcd(c,d)</p></li>
<li><p>lcm(a, c, d) = lcm(a, lcm(c, d))</p></li>
</ul></li>
</ul>
<h3 id="powerx-n">3.21.3. 50 power(x, n)</h3>
<ul>
<li><p>key:</p>
<ul>
<li>observation is easy</li>
</ul></li>
<li><p>careful</p>
<ul>
<li><p>abs(int) could be dangerous, the following code is more appropriate.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">abs</span>((<span class="keyword">int64_t</span>)n);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="search-in-rotated-sorted-array-ii">3.21.4. 81. Search in Rotated Sorted Array II</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation is easy</p></li>
<li><p>detail: margin, especially when l &gt; r</p></li>
</ul></li>
</ul>
<h3 id="shortest-subarray-with-sum-at-least-k">3.21.5. 862 shortest subarray with sum at least k</h3>
<ul>
<li>key
<ul>
<li>observation: dp that it is similar to max sub problem, this problem is more complicated since we need to search more from max(i-1)'s starting point to i ( in the previous problem, we do not need this step), during the search we can use bs. I thought about how to decrease the searching points during this linear o(n) search, obviously we don't need to search those i with sum(i to j) &lt;0. but here we need N2 storage for the sum(i, j), we could have turn this to linear storage by finding the basis of these sum(i, j) -&gt; sum(i). we only need o(n) to store these element and the algorithm turn to the alternative .</li>
<li>alternative algorithm: the second algorithm, we can keep more of the array ( in previous problem it is only 1 element min(sum(j)) j &lt;i ), this time we want more elements, the key of the elements is that we want them increasing, to make this happen we do the following: if we find out that in i's time we have sum(i) &lt; array(j) we pop the array until sum(i) is in the array and array is increasing. improvement here: we can discard sum(i) after it's usage since we know that no matter what, substring starts with i will only grow larger.</li>
</ul></li>
</ul>
<h3 id="longest-duplicate-substring">3.21.6. 1044. Longest Duplicate Substring</h3>
<ul>
<li>key
<ul>
<li>observe; we separate this to n subproblems ( find dup substring length = i) and we always know that if longest length = g, then i&lt;=g =&gt; I(find sub) = 1 and i &gt; g I (find sub) = -1 . so we use binary search to connect n subproblems. for each subproblem we use rolling hash table to get themO(n) * O(logN) = O(N^2)</li>
</ul></li>
</ul>
<h3 id="median-of-two-sorted-arrays">3.21.7. 4. Median of Two Sorted Arrays</h3>
<ul>
<li><p>key:</p>
<ul>
<li><p>observation: median = find i and j to separate the 2 arrays. so we don't have subproblems in this problem, instead it is a rather easy searching =&gt; we can even find a mono array to accelerate the searching. it is actually a 2 way BS, something like(0001, 1110) you can do 2 way to shorten the paragraph since there are less constraint on the mid variable, but doing my way as a 1 way BS is more explicit but more complicated.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums1.<span class="built_in">size</span>(), m = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> i = (m+n)%<span class="number">2</span>==<span class="number">0</span> ? <span class="built_in">max</span>((n-m)/<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>) : <span class="built_in">max</span>((n-m<span class="number">-1</span>)/<span class="number">2</span>, <span class="number">-1</span>), r = !(m+n)%<span class="number">2</span> ? <span class="built_in">min</span>((m+n)/<span class="number">2</span><span class="number">-1</span>,n<span class="number">-1</span>): <span class="built_in">min</span>((m+n<span class="number">-1</span>)/<span class="number">2</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> mid = (i+r)/<span class="number">2</span>, mid_2 = (n+m)%<span class="number">2</span>==<span class="number">0</span> ? (m+n)/<span class="number">2</span>-mid : (m+n+<span class="number">1</span>)/<span class="number">2</span>-mid, j;</span><br><span class="line">    <span class="keyword">if</span> ( n == <span class="number">0</span> ) <span class="keyword">return</span> m%<span class="number">2</span>==<span class="number">0</span> ? (nums2[m/<span class="number">2</span><span class="number">-1</span>] +nums2[m/<span class="number">2</span>])/<span class="number">2.0</span> : nums2[m/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> ( m == <span class="number">0</span> ) <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span> ? (nums1[n/<span class="number">2</span><span class="number">-1</span>] +nums1[n/<span class="number">2</span>])/<span class="number">2.0</span> : nums1[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span>( i &lt; r )&#123;</span><br><span class="line">        mid = <span class="built_in">ceil</span>((i+r)/<span class="number">2.0</span>);</span><br><span class="line">        mid_2 = (n+m)%<span class="number">2</span>==<span class="number">0</span> ? (m+n)/<span class="number">2</span>-mid<span class="number">-2</span> : (m+n+<span class="number">1</span>)/<span class="number">2</span>-mid<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">int</span> midr = mid == n<span class="number">-1</span> ? INT_MAX : nums1[mid+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid2r = mid_2 == m<span class="number">-1</span> ? INT_MAX : nums2[mid_2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (midl &gt;= mid2r) r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> i = mid ;</span><br><span class="line">    &#125;</span><br><span class="line">    j = (n+m)%<span class="number">2</span>==<span class="number">0</span> ? (m+n)/<span class="number">2</span>-i<span class="number">-2</span> : (m+n+<span class="number">1</span>)/<span class="number">2</span>-i<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">int</span> midl = i == <span class="number">-1</span> ? INT_MIN : nums1[i];</span><br><span class="line">    <span class="keyword">int</span> midr = i == n<span class="number">-1</span> ? INT_MAX : nums1[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> mid2l = j == <span class="number">-1</span> ? INT_MIN : nums2[j];</span><br><span class="line">    <span class="keyword">int</span> mid2r = j == m<span class="number">-1</span> ? INT_MAX : nums2[j+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> (n+m)%<span class="number">2</span>==<span class="number">0</span> ? (<span class="built_in">max</span>(midl, mid2l) + <span class="built_in">min</span>(midr, mid2r))/<span class="number">2.0</span></span><br><span class="line">                      : <span class="built_in">max</span>(midl, mid2l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>carefull:</p>
<ul>
<li>i+r/2 or ceil(i+r/2.0)</li>
<li>no max function with size_t</li>
</ul></li>
</ul>
<h3 id="find-k-th-smallest-pair-distance-1">3.21.8. 719. Find K-th Smallest Pair Distance</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>O(nlog(max-min) + nlog(n)) observation: a christmas tree can be shown here, we want a line=res so that nodes under res = k, at the same time the larger res is, nodes_under_k is larger. so we want this to solve the problem.</p>
<p><strong>Note</strong>: it is O(max-min) to search the nodes under line = res.</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_2222.JPG" alt="IMG_2222"><figcaption>IMG_2222</figcaption>
</figure></li>
</ul></li>
</ul>
<p>### 786. K-th Smallest Prime Fraction</p>
<ul>
<li>key
<ul>
<li>same as 719</li>
</ul></li>
<li>careful
<ul>
<li>BS update count &amp; stuff</li>
<li>count after j and margin conditions</li>
</ul></li>
</ul>
<h3 id="online-majority-element-in-subarray-1">3.21.9. Online Majority Element In Subarray</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(lenofquery)=O(n)\)</span> observation</p></li>
<li><p><span class="math inline">\(O(m*log(len ofsame))\)</span> observation: since we can store occurances and form an increasing array, we can search through the array and use binary search.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MajorityChecker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">    MajorityChecker(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) idx[arr[i]].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : idx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.second.<span class="built_in">size</span>() &lt; threshold) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> it1 = lower_bound(<span class="built_in">begin</span>(i.second), <span class="built_in">end</span>(i.second), left);</span><br><span class="line">        <span class="keyword">auto</span> it2 = upper_bound(<span class="built_in">begin</span>(i.second), <span class="built_in">end</span>(i.second), right);</span><br><span class="line">        <span class="keyword">if</span> (it2 - it1 &gt;= threshold) <span class="keyword">return</span> i.first;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fallingSquares(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; p) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[&#123;<span class="number">0</span>,<span class="number">1000000000</span>&#125;] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v:p) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; toAdd;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">int</span> len = v.second, a = v.first, b =v.first + v.second, h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">auto</span> it = mp.upper_bound(&#123;a,a&#125;);</span><br><span class="line">            <span class="keyword">if</span> (it != mp.<span class="built_in">begin</span>() &amp;&amp; (--it)-&gt;first.second &lt;= a) ++it;</span><br><span class="line">            <span class="keyword">while</span> (it != mp.<span class="built_in">end</span>() &amp;&amp; it-&gt;first.first &lt;b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &gt; it-&gt;first.first) toAdd.push_back(&#123;it-&gt;first.first,a,it-&gt;second&#125;);</span><br><span class="line">                <span class="keyword">if</span> (b &lt; it-&gt;first.second) toAdd.push_back(&#123;b,it-&gt;first.second,it-&gt;second&#125;);</span><br><span class="line">                h = <span class="built_in">max</span>(h, it-&gt;second);</span><br><span class="line">                it = mp.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            mp[&#123;a,b&#125;] = h + len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t:toAdd) mp[&#123;t[<span class="number">0</span>],t[<span class="number">1</span>]&#125;] = t[<span class="number">2</span>];</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, h + len);</span><br><span class="line">            ans.push_back(mx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="falling-squares-1">3.21.10. 699. Falling Squares</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(n^2 )\)</span> observation: save in map, use binary search and update</p></li>
<li><p><span class="math inline">\(O(nlogn)\)</span> observation: Similar to skyline concept, going from left to right the path is decomposed to consecutive segments, and each segment has a height. Each time we drop a new square, then update the level map by erasing &amp; creating some new segments with possibly new height. There are at most 2n segments that are created / removed throughout the process, and the time complexity for each add/remove operation is O(log(n)).</p></li>
<li><p><span class="math inline">\(O(n^2)\)</span> observation: using a Binary Search Tree, not necessarily a Segment Tree, just do the same job as the first map &amp; binary search solution. I don't get it why this is so much faster than mapping.</p></li>
<li><p><span class="math inline">\(O(n logn)\)</span> observation: use a Segment Tree, obviously we need to do range_sum &amp; range_query.</p></li>
</ul></li>
</ul>
<h3 id="rectangle-area-ii-1">3.21.11. 850. Rectangle Area II</h3>
<ul>
<li>key
<ul>
<li>$O(nm) $ observation: do all the settings square by square.</li>
<li><span class="math inline">\(O(n^2)\)</span> observation: discretion, do all the settings split by split.</li>
<li>$O(nlogn) $ observation: discretion + vanilla segment tree(since we have range_update $O(logn) $ )</li>
</ul></li>
<li><p>careful:</p>
<p>d</p></li>
</ul>
<h2 id="greedy-search-1">3.22. greedy search</h2>
<h3 id="wildcard-matching-2">3.22.1. wildcard matching</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation(unique trimming) trim all branches of * which is not the last bit.</p>
<p>imagine that take * =&gt; 0 as local greedy then until meet next *, local greedy is global greedy.</p></li>
</ul></li>
</ul>
<h3 id="remove-k-digits-1">3.22.2. 402. Remove K Digits</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation:(unique trimming) set the 1st element =&gt; 1+1st element =&gt; 1+2...</p>
<p><strong>Proof</strong>: (1) DP[1] is setting 1st as smallest</p>
<p>​ (2) DP[2] is setting 2nd as smallest and can be derived from DP[1]</p></li>
</ul></li>
</ul>
<h3 id="remove-duplicate-letters-1">3.22.3. Remove Duplicate Letters</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation:(unique trimming) basically same as <a href="https://leetcode.com/problems/remove-k-digits" target="_blank" rel="noopener">Remove K Digits</a> , adding constraints on poping operation, goal is to set the first bit as soon as possible.</p>
<p><strong>Proof</strong>: actually a pretty trivial proof, that at ith level we set the smallest possible outcome for [1:i], since the poped element can replenished after ith step and we'll always get smaller outcome by poping those items. So it is a greedy local optimal solution which yields global optimal.</p></li>
</ul></li>
</ul>
<h3 id="minimum-number-of-refueling-stops-1">3.22.4. 871. Minimum Number of Refueling Stops</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation:(directly solving subproblem) go further in t stops and you local optimal = global optimal</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_3698-7375059.JPG" alt="IMG_3698"><figcaption>IMG_3698</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="ipo">3.22.5. 502. IPO</h3>
<ul>
<li>key
<ul>
<li>greedy, go for the largest possible =&gt; heap . same as 871</li>
</ul></li>
</ul>
<h3 id="patching-array">3.22.6. 330. Patching Array</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: 从[1：最小的set里的数]这个区间出发，1）不断找当前不能表示的最小数是什么 2）如果能cover掉一些白送的数，不断加上白送的数，维持一个能表示的最大区间。思维固化，只想到1248，但其实1245也是能包括0到12的数的。</p>
<p><strong>Proof</strong>: (0) we change the min problem to max =&gt; DP[i] is the largest number to cover by adding i elements.</p>
<p>​ (1) smallest problem DP[1] is the largest cover by adding 1</p>
<p>​ (2) the next DP[i+1] can be solved by adding the number DP[i] can't solve. proof is easy.</p></li>
</ul></li>
</ul>
<h3 id="course-schedule-iii-1">3.22.7. 630. Course Schedule III</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: we prove <code>DP[i] means optimal from [0:i]</code></p>
<p><span class="math inline">\(DP[q][j] = min_{i \leq q}(DP[i][j-1] + course[i] )\)</span> =&gt; so to get min(DP[i][j-1]) is equivalent to pop the largest.</p>
<p><strong>Proof</strong>: 用数学归纳法证明：如果是更新+1，那么就是直接加新来的；如果是平行+0，那么要么是加了最新的然后原来的j-1，要么不加最新的。这个取决于最新的和原来最大值的大小。简而言之，greedy直接把min(DP[i][j-1])这一项给解出来了，而不需要大费周折去更新他。这个简化的关键是发现DP[j-1]和DP[j]其实差的那一个element是j中的最大值，有了这一个观察就可以直接求element中的最大值从而直接比较DP[j-1]和DP[j]了，而不需要具体的DP[j-1]的值，也就不需要DP了。</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_5430.JPG" alt="IMG_5430"><figcaption>IMG_5430</figcaption>
</figure>
<p><strong>Proof</strong>: if DP[i] is have i</p></li>
</ul></li>
</ul>
<h3 id="create-maximum-number">3.22.8. 321. Create Maximum Number</h3>
<ul>
<li>careful:
<ul>
<li>vector &gt; vector =&gt; 逐个比较。而不是比较整体int的大小</li>
<li>临时变量不是左值不能放在引用参数上。</li>
</ul></li>
</ul>
<h2 id="sorting">3.23. sorting</h2>
<ul>
<li><p>深刻的理解多路快排。第 75 题。</p></li>
<li><p>链表的排序，插入排序(第 147 题)和归并排序(第 148 题)</p></li>
<li><p>桶排序和基数排序。第 164 题。</p></li>
<li><p>&quot;摆动排序&quot;。第 324 题。</p></li>
<li><p>两两不相邻的排序。第 767 题，第 1054 题。</p></li>
<li><p>&quot;饼子排序&quot;。第 969 题。</p></li>
</ul>
<h3 id="maximum-gap">3.23.1. 164. Maximum Gap</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: bucket sort =&gt; since we only need the interval between 2 buckets, and max interval &gt;= (max-min)/n-1 which is average interval, so bucket size have to be (max-min)/n-1 [) or smaller so that we satisfy size &lt; interval. and basically that's the key point. so that every possible max pair lies in adajacant buckets.</li>
</ul>
<p><strong>Note</strong>: bucket sort's first step is a partial sorting where you fill number into gaps, and we only need gaps in this problem.</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxE = *max_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> minE = *min_element(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">double</span> len = <span class="keyword">double</span>(maxE-minE)/<span class="keyword">double</span>(n<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxA(n,INT_MIN);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minA(n,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (nums[i]-minE)/len;</span><br><span class="line">            maxA[index] = <span class="built_in">max</span>(maxA[index],nums[i]);</span><br><span class="line">            minA[index] = <span class="built_in">min</span>(minA[index],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>, prev = maxA[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(minA[i]==INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">            gap = <span class="built_in">max</span>(gap,minA[i]-prev);</span><br><span class="line">            prev = maxA[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="first-missing-positive">3.23.2. 41. First Missing Positive</h3>
<ul>
<li><p>key</p>
<ul>
<li><p><span class="math inline">\(O(nlog(n))\)</span> observation: sort &amp; iterate</p></li>
<li><p>$O(n) $ observation: partial soring technique: first we know possible answer = 1-&gt;sizeofarray, so if 1 -&gt; sizeofarray is on where they are, then we can go in one turn. so go for swaping 1-&gt;sizeofarray to where they should be .</p>
<p><strong>Note</strong>: this stem from the fact we can sort 1-&gt;n in O(n).</p></li>
</ul></li>
</ul>
<h2 id="math">3.24. math</h2>
<h3 id="sum-of-subarray-minimums-1">3.24.1. 907. Sum of Subarray Minimums</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: 这个问题本来的局势是把所有幂集的最小值加起来，我们先对最小值做一个聚集，然后通过问题本身的性质进行解决。</li>
</ul></li>
</ul>
<h3 id="pattern-1">3.24.2. 456. 132 Pattern</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: (unique trimming) the 132 pattern, as we can see we'll expedite the progress if we go from right to left and search for 32 pattern(why? since we can use greedy to keep the largest (3,2) pairs so far), the greedy can be proved that the greedy method is optimal as we move to[i+1,end]. prove by contrast, if point i have 132 pattern but not with greedy, then either 3/2 is not largest. In other words, keeping 32 pattern to be the largest possible will always yield best results.</p>
<p><strong>Proof</strong>: (0) can be proved that problem reduce to several partial largest (3,2) pairs, would't call it greedy though</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_3650.JPG" alt="IMG_3650"><figcaption>IMG_3650</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="couples-holding-hands-1">3.24.3. 765. Couples Holding Hands</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: when one needs to keep i == function[i] of an array =&gt; use circle swapping.</p>
<p>such as i == row[i] where you sort an (0:i) array, or ptn(pos(ptn(row[i]))) which means the correct position row[i] should be, e.g. row[i] = 5, then it should be whereever next to 6(only one position), so by circling swapping, eventually i = 0 gets its correct element then we move to i = 1 and more. There are m distinct no overlap circling rounds and can be proved optimality.</p>
<p><strong>Note</strong>: why circles ? because every swap fix 1 pixel, and doing in circle do not affect other elements beside the circle. 如果有一个圈的话，每一次修好一个元素，一个圈的元素数又是固定的，且对圈外无影响，所以必定会修好且最优。图像化来想的话，一个圈的就是m个cuples，每对cuples之间在i,i+1有从两对cuples中各出一个元素。</p></li>
</ul></li>
</ul>
<h3 id="minimum-number-of-k-consecutive-bit-flips">3.24.4. 995. Minimum Number of K Consecutive Bit Flips</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>greedy: always fix the current node. Before and after any flip, any bit in the sequence of 1 starting from the left-most bit should not be flipped anymore.</p>
<p><strong>Proof</strong>: The <em>greedy claim</em> gives a solution <code>S</code>. Without loss of generosity, let the i-th bit be the first 0 bit. Suppose the <em>greedy claim</em> above is false, then there must be a better (better means less flips) solution <code>S'</code> in which bits in range <code>[J , J + K - 1]</code> are flipped and <code>J &lt; i</code>. There could be multiple <code>J</code>. Let <code>j</code> be the smallest possible <code>J</code>. Since <code>A[j]</code> now is 1 (why? because <code>j), if we flip it,</code>A[j]<code>becomes 0.</code>A[j]<code>finally should be 1, so</code>S'<code>must flips</code>A[j]<code>again sometime later. As</code>j<code>is the smallest of</code>J<code>,</code>S'<code>can't flip anything left to</code>A[j]<code>, which means only flipping the range</code>[j , j + K - 1]<code>can flip</code>A[j]<code>back to 1. See? we flipped</code>[j , j + K - 1]<code>, then again</code>[j , j + K - 1]<code>.</code>S'<code>wasts flips. If</code>S'<code>exists, we can find a third solution</code>S''<code>that is strictly even better than</code>S'<code>. And we can do this induction infinitely and find a solution needs only 0 or even negative number of flips. -- That is of course impossible. Actually, the induction of finding even better solutions will eventually give you</code>S<code>.</code>S<code>is strictly better than</code>S`? Of course not! -- So the <em>greedy claim</em> above is NOT false. So, the <em>greedy claim</em> is true.</p>
<p><strong>Proof</strong>2: 首先确定每一个点最多flip一次，然后对每个点排序，找到最左的点，它的左边一定全是1，然后这个点到第二个点中间一定全是1。就证完了其实不是greedy，因为只有一个解。</p></li>
</ul></li>
</ul>
<h3 id="three-equal-parts">3.24.5. 927. Three Equal Parts</h3>
<ul>
<li><p>key</p>
<ul>
<li>observation: easy problem</li>
</ul>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; threeEqualParts(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = A.<span class="built_in">size</span>(); <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;index; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=sz<span class="number">-1</span>; i++) <span class="keyword">if</span>(A[i]==<span class="number">1</span>) index.push_back(i);</span><br><span class="line">        <span class="keyword">if</span>(index.empty()) <span class="keyword">return</span> &#123;<span class="number">0</span>, sz<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(index.<span class="built_in">size</span>()%<span class="number">3</span>) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = sz <span class="number">-1</span> - index.back(); <span class="keyword">int</span> start = index[index.<span class="built_in">size</span>()/<span class="number">3</span><span class="number">-1</span>], start_n = index[index.<span class="built_in">size</span>()/<span class="number">3</span>], <span class="built_in">end</span> = index[index.<span class="built_in">size</span>()/<span class="number">3</span>*<span class="number">2</span><span class="number">-1</span>], end_n = index[index.<span class="built_in">size</span>()/<span class="number">3</span>*<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(start_n-start<span class="number">-1</span> &gt;= m &amp;&amp; end_n-<span class="built_in">end</span><span class="number">-1</span> &gt;= m)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur_s = start, cur_n = <span class="built_in">end</span>, cur_f = index.back();</span><br><span class="line">            <span class="keyword">while</span>(cur_s!=index[<span class="number">0</span>] &amp;&amp; cur_n!=start_n &amp;&amp; cur_f!=end_n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[cur_s]!=A[cur_n] || A[cur_n]!=A[cur_f]) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">                cur_s--, cur_n--, cur_f--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur_s==index[<span class="number">0</span>] &amp;&amp; cur_n==start_n &amp;&amp; cur_f==end_n) <span class="keyword">return</span> &#123;start+m, <span class="built_in">end</span>+m+<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="candy">3.24.6. 135. Candy</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: left recursion will set all + left to m, right recursion set m and + right to m.</p>
<figure>
<img src="/2019/12/03/datastructure-algorithm/IMG_9352.JPG" alt="IMG_9352"><figcaption>IMG_9352</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="random-pick-with-blacklist">3.24.7. 710. Random Pick with Blacklist</h3>
<ul>
<li>key
<ul>
<li>observation: math sampling problem =&gt; how to sample from set(N - blacklist) ? since we want prob = 1/len(set(N-blacklist)) = 1/(N-B), so we choose from 0-&gt;N-B to make sure whitelist prob is correct then we remap the blacklist to whitelist that&gt;N-B, the reason we do so is because randint can only choose from continuous numbers.</li>
</ul></li>
</ul>
<h3 id="sum-of-subsequence-widths">3.24.8. Sum of Subsequence Widths</h3>
<ul>
<li><p>key</p>
<ul>
<li><p>observation: sort first then, set each pixel as first / second</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count += -A[i] * (<span class="number">1</span>&lt;&lt;i <span class="number">-1</span>) + A[i] * (<span class="number">1</span>&lt;&lt;n-i<span class="number">-1</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>optimization: to avoid overflow use * constant &amp; + constant, we compute count in iterative manner :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = (A[i]%<span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>)+(count*<span class="number">2</span>)%<span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>))%<span class="keyword">int</span>(<span class="number">1e9</span>+<span class="number">7</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<p>### 1074. Number of Submatrices That Sum to Target</p>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(n^3)\)</span> observation: first choose 2 rows, reduce the problem to find subarray if we know the sum of all rows in between, so we sum prefix of matrix. basically this is <span class="math inline">\(O(n^2)\)</span> row choosing * <span class="math inline">\(O(n)\)</span> find target.</li>
</ul></li>
</ul>
<h3 id="transform-to-chessboard">3.24.9. Transform to Chessboard</h3>
<ul>
<li>key
<ul>
<li><span class="math inline">\(O(n)\)</span> observation: this is a easy problem actually, see if <code>sz is odd/even</code> and it's done.</li>
</ul></li>
</ul>
<h2 id="brutal">3.25. brutal</h2>
<h3 id="binary-watch-2">3.25.1. 401. Binary Watch</h3>
<ul>
<li>key: ez</li>
</ul>
<h3 id="maximum-length-of-a-concatenated-string-with-unique-characters">3.25.2. 1239. Maximum Length of a Concatenated String with Unique Characters</h3>
<ul>
<li><p>trick: a great way to do exhaustion for all 0/1 pairs (01010101).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(n bits)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = all stored <span class="built_in">size</span>)&#123;</span><br><span class="line"></span><br><span class="line">  	stored.push_back(a | b)  <span class="comment">// every time push back same size of stored(size x 2) and stored are the all permutations of example.</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="tricks">3.26. tricks</h2>
<ul>
<li>comparison 1 to n, saving possible combinations of 1 and n and do comparing with the saved sets instead of comparing n times.
<ul>
<li>952 Largest Component Size by Common Factor</li>
<li>1178 Number of Valid Words for Each Puzzle</li>
<li>128 Longest Consecutive Sequence</li>
<li>839 Similar String Groupsth</li>
</ul></li>
<li>sorting, if get stuck
<ul>
<li>1042 Flower Planting With No Adjacent</li>
<li>3sum</li>
</ul></li>
<li>hash map(bucket), used to reduce possible results
<ul>
<li>1074 Number of Submatrices That Sum to Target</li>
<li>421 Maximum XOR of Two Numbers in an Array</li>
<li>336 Palindrome Pairs</li>
</ul></li>
<li>other
<ul>
<li>%2 =&gt; &amp;1 ==1</li>
</ul></li>
<li>moore-voting for
<ul>
<li>169</li>
<li>1157</li>
</ul></li>
<li>discretion
<ul>
<li>850 Rectangle Area II</li>
</ul></li>
</ul>

      
    </div>
    
    
    

    <div>
      
        
      
    </div>
    
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt="Benson WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="Benson Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/19/Complexity_Theory/" rel="next" title="Complexity Theory">
                <i class="fa fa-chevron-left"></i> Complexity Theory
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type = "text/javascript" src = "//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5dd409321289b452" async = "async" ></script>
</div>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NzYxNi8yNDExNA"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://tva1.sinaimg.cn/large/006y8mN6gy1g96p07mbexj30uf0u0npd.jpg"
                alt="Benson" />
            
              <p class="site-author-name" itemprop="name">Benson</p>
              <p class="site-description motion-element" itemprop="description">Benson's personal blog, including stats, cs, math, among others.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="bensonuouououow@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/bensonuouououo" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-globe"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/bensonuouououo/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-globe"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chuangzaoshi.com/code" title="创造狮导航" target="_blank">创造狮导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.36zhen.com/t?id=3448" title="前端书籍资料" target="_blank">前端书籍资料</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://e.xitu.io/" title="掘金酱" target="_blank">掘金酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="印记中文" target="_blank">印记中文</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#data-structures"><span class="nav-text">1. data structures</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#linear-adt"><span class="nav-text">1.1. linear ADT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-text">1.1.1. vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-text">1.1.2. map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-text">1.1.3. stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap"><span class="nav-text">1.1.4. heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset"><span class="nav-text">1.1.5. bitset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tree-adt"><span class="nav-text">1.2. tree ADT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree"><span class="nav-text">1.2.1. binary tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-special-tree"><span class="nav-text">1.2.1.1. binary special tree</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#segment-tree"><span class="nav-text">1.2.1.1.1. segment tree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-search-tree"><span class="nav-text">1.2.1.2. binary search tree</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#vanila-search-tree"><span class="nav-text">1.2.1.2.1. vanila search tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#red-black-tree"><span class="nav-text">1.2.1.2.2. red-black tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#self-balance-tree"><span class="nav-text">1.2.1.2.3. self-balance tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#splay-tree"><span class="nav-text">1.2.1.2.4. splay tree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#heap-1"><span class="nav-text">1.2.1.3. heap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#skew-heap"><span class="nav-text">1.2.1.3.1. skew heap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#heap-2"><span class="nav-text">1.2.1.3.2. ..heap</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#huffman-tree"><span class="nav-text">1.2.1.4. huffman tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binary-index-tree"><span class="nav-text">1.2.1.5. binary index tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#general-tree"><span class="nav-text">1.2.2. general tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#b-tree"><span class="nav-text">1.2.2.1. B tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#btree"><span class="nav-text">1.2.2.2. B+tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trie"><span class="nav-text">1.2.2.3. Trie</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#problems-algorithms"><span class="nav-text">2. problems &amp; algorithms</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#search"><span class="nav-text">2.1. search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#depth-first-search"><span class="nav-text">2.1.1. depth first search</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tail-recursive"><span class="nav-text">2.1.1.1. tail recursive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#breadth-first-search"><span class="nav-text">2.1.2. breadth first search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-programming"><span class="nav-text">2.1.3. dynamic programming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-search"><span class="nav-text">2.1.4. binary search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#greedy-search"><span class="nav-text">2.1.5. greedy search</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort"><span class="nav-text">2.2. sort</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insertion-sort"><span class="nav-text">2.2.1. insertion sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bubble-sort"><span class="nav-text">2.2.2. bubble sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selection-sort"><span class="nav-text">2.2.3. selection sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge-sort"><span class="nav-text">2.2.4. merge sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-sort"><span class="nav-text">2.2.5. heap sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-sort"><span class="nav-text">2.2.6. count sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bucket-sort-improved-count-sort"><span class="nav-text">2.2.7. bucket sort (improved count sort)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#radix-sort"><span class="nav-text">2.2.8. radix sort</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#graph"><span class="nav-text">2.3. graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#topological-sorting"><span class="nav-text">2.3.1. topological sorting</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shortest-path"><span class="nav-text">2.3.2. shortest path</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dijkstra"><span class="nav-text">2.3.2.1. Dijkstra</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#floyd"><span class="nav-text">2.3.2.2. Floyd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bellman-ford"><span class="nav-text">2.3.2.3. Bellman-Ford</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union-find"><span class="nav-text">2.3.3. union find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strongly-connected-components"><span class="nav-text">2.3.4. strongly connected components</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-spanning-tree"><span class="nav-text">2.3.5. minimum spanning tree</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#amotized-analysis"><span class="nav-text">2.4. amotized analysis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aggregate-analysis"><span class="nav-text">2.4.1. aggregate analysis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#accounting-method"><span class="nav-text">2.4.2. accounting method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#potential-method"><span class="nav-text">2.4.3. potential method</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#other"><span class="nav-text">2.5. other</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#moore-voting"><span class="nav-text">2.5.1. moore-voting</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#leetcode"><span class="nav-text">3. Leetcode</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#int"><span class="nav-text">3.1. int</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#no.7-iterate-reverse-int"><span class="nav-text">3.1.1. no.7 iterate &amp; reverse int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#no.9-iterate-reverse-int-2"><span class="nav-text">3.1.2. no.9 iterate &amp; reverse int 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#no.13-iterate-assign"><span class="nav-text">3.1.3. no.13 iterate &amp; assign</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-text">3.2. string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#no.28-iterate"><span class="nav-text">3.2.1. no.28 iterate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#no.859-iterate-swap"><span class="nav-text">3.2.2. no.859 iterate &amp; swap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector-1"><span class="nav-text">3.3. vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#no.26-iterate-eraseassign"><span class="nav-text">3.3.1. no.26 iterate &amp; erase/assign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#no.665-iterate-change-value-math-problem"><span class="nav-text">3.3.2. no.665 iterate &amp; change value (math problem)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-interval"><span class="nav-text">3.3.3. 57. Insert Interval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert-delete-getrandom-o1"><span class="nav-text">3.3.4. 380. Insert Delete GetRandom O(1)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linked-list"><span class="nav-text">3.4. linked list</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#no.21-iterate-merge-2-list"><span class="nav-text">3.4.1. no.21 iterate &amp; merge 2 list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pointer"><span class="nav-text">3.5. 2-pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sliding-window"><span class="nav-text">3.6. sliding window</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack-1"><span class="nav-text">3.7. stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#push-pop"><span class="nav-text">3.7.1. 20. push &amp; pop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xxx.-simplify-path"><span class="nav-text">3.7.2. xxx. Simplify Path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xxx.-basic-calculator"><span class="nav-text">3.7.3. xxx. Basic Calculator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section"><span class="nav-text">3.7.4. </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-k-digits"><span class="nav-text">3.7.5. 402. Remove K Digits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-of-subarray-minimums"><span class="nav-text">3.7.6. 907 Sum of Subarray Minimums</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern"><span class="nav-text">3.7.7. 456 132 Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#largest-rectangle-in-histogram"><span class="nav-text">3.7.8. Largest Rectangle in Histogram</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximal-rectangle"><span class="nav-text">3.7.9. 85. Maximal Rectangle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicate-letters"><span class="nav-text">3.7.10. Remove Duplicate Letters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#odd-even-jump"><span class="nav-text">3.7.11. 975 Odd Even Jump</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trapping-rain-water"><span class="nav-text">3.7.12. 42. Trapping Rain Water</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap-3"><span class="nav-text">3.8. heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#the-skyline-problem-i-wouldnt-say-its-divideconcurd"><span class="nav-text">3.8.1. the skyline problem (i wouldn&#39;t say it&#39;s divide&amp;concurd)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-k-th-smallest-pair-distance"><span class="nav-text">3.8.2. 719. Find K-th Smallest Pair Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-median-from-data-stream"><span class="nav-text">3.8.3. 295. Find Median from Data Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trapping-rain-water-ii"><span class="nav-text">3.8.4. 407. Trapping Rain Water II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-th-smallest-prime-fraction"><span class="nav-text">3.8.5. 786. K-th Smallest Prime Fraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-cost-to-hire-k-workers"><span class="nav-text">3.8.6. 857. Minimum Cost to Hire K Workers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swim-in-rising-water"><span class="nav-text">3.8.7. 778. Swim in Rising Water</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque"><span class="nav-text">3.9. deque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sliding-window-maximum"><span class="nav-text">3.9.1. 239. Sliding Window Maximum</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#maphash-table"><span class="nav-text">3.10. map(hash table)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#odd-even-jump-1"><span class="nav-text">3.10.1. 975. Odd Even Jump</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-frequency-stack"><span class="nav-text">3.10.2. Maximum Frequency Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-xor-of-two-numbers-in-an-array"><span class="nav-text">3.10.3. 421 Maximum XOR of Two Numbers in an Array</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#union-find-1"><span class="nav-text">3.11. union find</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#couples-holding-hands"><span class="nav-text">3.11.1. 751 Couples Holding Hands</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redundant-connection-ii"><span class="nav-text">3.11.2. 685. Redundant Connection II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#largest-component-size-by-common-factor"><span class="nav-text">3.11.3. 952. Largest Component Size by Common Factor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bricks-falling-when-hit"><span class="nav-text">3.11.4. 803. Bricks Falling When Hit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimize-malware-spread-ii"><span class="nav-text">3.11.5. 928. Minimize Malware Spread II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimize-malware-spread"><span class="nav-text">3.11.6. 924. Minimize Malware Spread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-consecutive-sequence"><span class="nav-text">3.11.7. 128. Longest Consecutive Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#similar-string-groups"><span class="nav-text">3.11.8. 839. Similar String Groups</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#most-stones-removed-with-same-row-or-column"><span class="nav-text">3.11.9. Most Stones Removed with Same Row or Column</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bt"><span class="nav-text">3.12. bt</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-tree-postorder-traversal"><span class="nav-text">3.12.1. Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-of-distances-in-tree"><span class="nav-text">3.12.2. 834. Sum of Distances in Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lca"><span class="nav-text">3.12.3. 236. LCA</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#construct-binary-tree-from-inorder-and-postorder-traversal"><span class="nav-text">3.12.4. 106. Construct Binary Tree from Inorder and Postorder Traversal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bst"><span class="nav-text">3.13. bst</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#count-of-smaller-numbers-after-self-from-dc"><span class="nav-text">3.13.1. 315. Count of Smaller Numbers After Self (from D&amp;C)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#delete-bst"><span class="nav-text">3.13.2. 450 delete BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-complete-tree-nodes"><span class="nav-text">3.13.3. 222. Count Complete Tree Nodes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bst-iterator"><span class="nav-text">3.13.4. BST iterator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#segment-tree-1"><span class="nav-text">3.14. segment tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#online-majority-element-in-subarray"><span class="nav-text">3.14.1. 1157. Online Majority Element In Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#falling-squares"><span class="nav-text">3.14.2. 699 Falling Squares</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rectangle-area-ii"><span class="nav-text">3.14.3. 850. Rectangle Area II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#my-calendar-iii"><span class="nav-text">3.14.4. 732. My Calendar III</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#trie-1"><span class="nav-text">3.15. Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#number-of-valid-words-for-each-puzzle"><span class="nav-text">3.15.1. 1178. Number of Valid Words for Each Puzzle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-univalue-path"><span class="nav-text">3.15.2. 687. Longest Univalue Path</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vertical-order-traversal-of-a-binary-tree"><span class="nav-text">3.15.3. 987. Vertical Order Traversal of a Binary Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-1"><span class="nav-text">3.15.4. </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#top-k-frequent-words"><span class="nav-text">3.15.5. 692. Top K Frequent Words</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prefix-and-suffix-search"><span class="nav-text">3.15.6. 745. Prefix and Suffix Search</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#graph-1"><span class="nav-text">3.16. graph</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#reachable-nodes-in-subdivided-graph"><span class="nav-text">3.16.1. 882. Reachable Nodes In Subdivided Graph</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-search-ii"><span class="nav-text">3.16.2. 212. Word Search II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#evaluate-divisionfloyd"><span class="nav-text">3.16.3. 399. Evaluate Division(floyd)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-items-by-groups-respecting-dependenciestopo"><span class="nav-text">3.16.4. 1203. Sort Items by Groups Respecting Dependencies(topo)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flower-planting-with-no-adjacent"><span class="nav-text">3.16.5. 1042. Flower Planting With No Adjacent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-eventual-safe-states-find-circles"><span class="nav-text">3.16.6. 802. Find Eventual Safe States (find circles)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-graph-bipartite"><span class="nav-text">3.16.7. 785. Is Graph Bipartite</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-height-trees"><span class="nav-text">3.16.8. 310. Minimum Height Trees</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#divide-concur-basic-bottom-up"><span class="nav-text">3.17. divide &amp; concur (basic bottom-up)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#findi-j-findi-1-j-findi-j1"><span class="nav-text">3.17.1. 240. find(i, j) = find(i-1, j) || find(i, j+1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kth-largest-element-in-an-array"><span class="nav-text">3.17.2. 215. Kth Largest Element in an Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beautiful-array"><span class="nav-text">3.17.3. 932 beautiful array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-of-range-sum"><span class="nav-text">3.17.4. Count of Range Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reverse-pairs"><span class="nav-text">3.17.5. 493. Reverse Pairs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#permutation-sequence"><span class="nav-text">3.17.6. 60. Permutation Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-2"><span class="nav-text">3.17.7. </span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-programming-1"><span class="nav-text">3.18. dynamic programming</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sumi-j"><span class="nav-text">3.18.1. 303 sum(i, j)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxsolutioni"><span class="nav-text">3.18.2. 198 maxsolution(i)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxsumi-j"><span class="nav-text">3.18.3. 53. maxsum(i, j)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxi-j"><span class="nav-text">3.18.4. 392. max(i, j)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maxi"><span class="nav-text">3.18.5. 91 max(i)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#continuous-subarray-sum"><span class="nav-text">3.18.6. 523. Continuous Subarray Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-concatenation-maximum-sum"><span class="nav-text">3.18.7. 1191 K-Concatenation Maximum Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freedom-trail"><span class="nav-text">3.18.8. 514. Freedom Trail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#valid-permutations-for-di-sequence"><span class="nav-text">3.18.9. 903. Valid Permutations for DI Sequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#burst-balloons"><span class="nav-text">3.18.10. 312. Burst Balloons</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wildcard-matching"><span class="nav-text">3.18.11. 44 wildcard matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#regular-expression-matching"><span class="nav-text">3.18.12. 10 Regular Expression Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-break-ii"><span class="nav-text">3.18.13. 140. Word Break II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stickers-to-spell-word"><span class="nav-text">3.18.14. 691. Stickers to Spell Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#odd-even-jump-2"><span class="nav-text">3.18.15. 975. Odd Even Jump</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-number-of-refueling-stops"><span class="nav-text">3.18.16. 871. Minimum Number of Refueling Stops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#race-car"><span class="nav-text">3.18.17. 818. Race Car</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#course-schedule-iii"><span class="nav-text">3.18.18. 630. Course Schedule III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jump-game-ii"><span class="nav-text">3.18.19. Jump Game II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-profit-in-job-scheduling"><span class="nav-text">3.18.20. 1235. Maximum Profit in Job Scheduling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partition-array-for-maximum-sum"><span class="nav-text">3.18.21. 1043. Partition Array for Maximum Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#best-time-to-buy-and-sell-stock-iii"><span class="nav-text">3.18.22. Best Time to Buy and Sell Stock III</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#depth-first-search-1"><span class="nav-text">3.19. depth first search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#addopeartion"><span class="nav-text">3.19.1. 282 addopeartion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-of-smaller-numbers-after-self-from-dc-1"><span class="nav-text">3.19.2. 315. Count of Smaller Numbers After Self (from D&amp;C)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freedom-trail-1"><span class="nav-text">3.19.3. 514. Freedom Trail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-watch"><span class="nav-text">3.19.4. 401 Binary Watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#different-ways-to-add-parentheses"><span class="nav-text">3.19.5. Different Ways to Add Parentheses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#upper-lower-letters"><span class="nav-text">3.19.6. upper lower letters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#restore-ip-addresses"><span class="nav-text">3.19.7. 93. Restore IP Addresses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#additive-number"><span class="nav-text">3.19.8. 306 additive number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-queens"><span class="nav-text">3.19.9. 51. N-Queens</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#permutations-ii"><span class="nav-text">3.19.10. 47. Permutations II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gray-code"><span class="nav-text">3.19.11. 89. Gray Code</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#palindrome-partitioning"><span class="nav-text">3.19.12. 131. Palindrome Partitioning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#letter-combinations-of-a-phone-number"><span class="nav-text">3.19.13. 17. Letter Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-ladder-ii"><span class="nav-text">3.19.14. 126. Word Ladder II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wildcard-matching-1"><span class="nav-text">3.19.15. 44. Wildcard Matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sudoku-solver"><span class="nav-text">3.19.16. 37. Sudoku Solver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stickers-to-spell-word-1"><span class="nav-text">3.19.17. Stickers to Spell Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#number-of-squareful-arrays"><span class="nav-text">3.19.18. 996. Number of Squareful Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tiling-a-rectangle-with-the-fewest-squares"><span class="nav-text">3.19.19. 1240. Tiling a Rectangle with the Fewest Squares</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-paths-iii"><span class="nav-text">3.19.20. 980. Unique Paths III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#decoded-string-at-index"><span class="nav-text">3.19.21. 888. Decoded String at Index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swim-in-rising-water-1"><span class="nav-text">3.19.22. 778. Swim in Rising Water</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-score-words-formed-by-letters"><span class="nav-text">3.19.23. 1255. Maximum Score Words Formed by Letters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-3"><span class="nav-text">3.19.24. </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-sum-of-3-non-overlapping-subarrays"><span class="nav-text">3.19.25. 689. Maximum Sum of 3 Non-Overlapping Subarrays</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#breadth-first-search-1"><span class="nav-text">3.20. breadth first search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-watch-1"><span class="nav-text">3.20.1. 401 Binary Watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#word-ladder-ii-1"><span class="nav-text">3.20.2. 126. Word Ladder II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stickers-to-spell-word-2"><span class="nav-text">3.20.3. 691. Stickers to Spell Word</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shortest-path-to-get-all-keys"><span class="nav-text">3.20.4. 864. Shortest Path to Get All Keys</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#smallest-sufficient-team"><span class="nav-text">3.20.5. 1125. Smallest Sufficient Team</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-width-of-binary"><span class="nav-text">3.20.6. 662. Maximum Width of Binary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-similar-strings"><span class="nav-text">3.20.7. 854. K-Similar Strings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#as-far-from-land-as-possible"><span class="nav-text">3.20.8. 1162. As Far from Land as Possible</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#binary-search-1"><span class="nav-text">3.21. binary search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#divide-2-numbers"><span class="nav-text">3.21.1. 29 divide 2 numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ugly-number"><span class="nav-text">3.21.2. 1201 Ugly Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#powerx-n"><span class="nav-text">3.21.3. 50 power(x, n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#search-in-rotated-sorted-array-ii"><span class="nav-text">3.21.4. 81. Search in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shortest-subarray-with-sum-at-least-k"><span class="nav-text">3.21.5. 862 shortest subarray with sum at least k</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#longest-duplicate-substring"><span class="nav-text">3.21.6. 1044. Longest Duplicate Substring</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#median-of-two-sorted-arrays"><span class="nav-text">3.21.7. 4. Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#find-k-th-smallest-pair-distance-1"><span class="nav-text">3.21.8. 719. Find K-th Smallest Pair Distance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#online-majority-element-in-subarray-1"><span class="nav-text">3.21.9. Online Majority Element In Subarray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#falling-squares-1"><span class="nav-text">3.21.10. 699. Falling Squares</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rectangle-area-ii-1"><span class="nav-text">3.21.11. 850. Rectangle Area II</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#greedy-search-1"><span class="nav-text">3.22. greedy search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wildcard-matching-2"><span class="nav-text">3.22.1. wildcard matching</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-k-digits-1"><span class="nav-text">3.22.2. 402. Remove K Digits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#remove-duplicate-letters-1"><span class="nav-text">3.22.3. Remove Duplicate Letters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-number-of-refueling-stops-1"><span class="nav-text">3.22.4. 871. Minimum Number of Refueling Stops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ipo"><span class="nav-text">3.22.5. 502. IPO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#patching-array"><span class="nav-text">3.22.6. 330. Patching Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#course-schedule-iii-1"><span class="nav-text">3.22.7. 630. Course Schedule III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#create-maximum-number"><span class="nav-text">3.22.8. 321. Create Maximum Number</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sorting"><span class="nav-text">3.23. sorting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-gap"><span class="nav-text">3.23.1. 164. Maximum Gap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#first-missing-positive"><span class="nav-text">3.23.2. 41. First Missing Positive</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#math"><span class="nav-text">3.24. math</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-of-subarray-minimums-1"><span class="nav-text">3.24.1. 907. Sum of Subarray Minimums</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pattern-1"><span class="nav-text">3.24.2. 456. 132 Pattern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#couples-holding-hands-1"><span class="nav-text">3.24.3. 765. Couples Holding Hands</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minimum-number-of-k-consecutive-bit-flips"><span class="nav-text">3.24.4. 995. Minimum Number of K Consecutive Bit Flips</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#three-equal-parts"><span class="nav-text">3.24.5. 927. Three Equal Parts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#candy"><span class="nav-text">3.24.6. 135. Candy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#random-pick-with-blacklist"><span class="nav-text">3.24.7. 710. Random Pick with Blacklist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sum-of-subsequence-widths"><span class="nav-text">3.24.8. Sum of Subsequence Widths</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transform-to-chessboard"><span class="nav-text">3.24.9. Transform to Chessboard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#brutal"><span class="nav-text">3.25. brutal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#binary-watch-2"><span class="nav-text">3.25.1. 401. Binary Watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maximum-length-of-a-concatenated-string-with-unique-characters"><span class="nav-text">3.25.2. 1239. Maximum Length of a Concatenated String with Unique Characters</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tricks"><span class="nav-text">3.26. tricks</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Benson</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      total visitors
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      people
    </span>
  

  
    <span class="site-pv">
      total read
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      times
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.staticfile.org/MathJax/MathJax-2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
