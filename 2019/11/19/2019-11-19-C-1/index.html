<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>C++ | Benson</title>
  <meta name="description" content="C++ 基础知识和语法">
<meta name="keywords" content="laungage">
<meta property="og:type" content="article">
<meta property="og:title" content="C++">
<meta property="og:url" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;11&#x2F;19&#x2F;2019-11-19-C-1&#x2F;index.html">
<meta property="og:site_name" content="Shicheng&#39;s Space">
<meta property="og:description" content="C++ 基础知识和语法">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;11&#x2F;19&#x2F;2019-11-19-C-1&#x2F;2019-11-19-C-1&#x2F;i1.png">
<meta property="og:updated_time" content="2019-11-19T11:54:55.077Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;steinsgate9.github.io&#x2F;2019&#x2F;11&#x2F;19&#x2F;2019-11-19-C-1&#x2F;2019-11-19-C-1&#x2F;i1.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://steinsgate9.github.io/2019/11/19/2019-11-19-C-1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Shicheng&#39;s Space" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/SteinsGate9" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Benson</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">B.Eng. at ZJU</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Boston, USA</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SteinsGate9" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/5568381899" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/bensonuouououo" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.linkedin.com/in/shicheng-huang-9a1176177/" target="_blank" title="Linkedin" data-toggle=tooltip data-placement=top><i class="icon icon-linkedin"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>个人知识记忆站，欢迎交流～</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/computer-science/">computer science</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/laungage/" rel="tag">laungage</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/laungage/" style="font-size: 13px;">laungage</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/computer-science/">computer science</a>
              </p>
              <p class="item-title">
                <a href="/2019/11/19/2019-11-19-C-1/" class="title">C++</a>
              </p>
              <p class="item-date">
                <time datetime="2019-11-19T04:50:43.000Z" itemprop="datePublished">2019-11-19</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">1. Overview</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Variable"><span class="toc-number">2.</span> <span class="toc-text">2. Variable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#data-type"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. data type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-type"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. basic type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-decoration"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. const decoration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const-class"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">2.1.2.1. const class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2.1.2.2. auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#register"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">2.1.2.3. register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">2.1.2.4. static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#extern"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">2.1.2.5. extern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mutable"><span class="toc-number">2.1.2.6.</span> <span class="toc-text">2.1.2.6. mutable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-local"><span class="toc-number">2.1.2.7.</span> <span class="toc-text">2.1.2.7. thread_local</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reference-decoration"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3. reference decoration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reference-of-variable-int-amp-xxx"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">2.1.3.1. reference of variable   (int &amp;xxx)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reference-of-pointer-int-amp-xxx"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">2.1.3.2. reference of pointer (int* &amp; xxx)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pointer-decoration"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4. pointer decoration</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pointer-of-varibale"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">2.1.4.1. pointer of varibale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array-of-pointer-指针数组）"><span class="toc-number">2.1.4.2.</span> <span class="toc-text">2.1.4.2. array of pointer (指针数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pointer-of-array（数组指针）"><span class="toc-number">2.1.4.3.</span> <span class="toc-text">2.1.4.3. pointer of array（数组指针）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-decoration"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5. array decoration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum-type"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6. enum type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-type"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7. string type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector-type"><span class="toc-number">2.1.8.</span> <span class="toc-text">2.1.8. vector type</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Class"><span class="toc-number">3.</span> <span class="toc-text">3. Class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#compiling-sequence"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. compiling sequence</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#construction-function"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1. construction function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#destruction-function"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2. destruction function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-function"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3. static function</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Function"><span class="toc-number">4.</span> <span class="toc-text">4. Function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#function-type"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. function type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-type-1"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. basic type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inline-decoration"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. inline decoration</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#declaration"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. declaration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Definition"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. Definition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overload-重载"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. overload(重载)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#override-重写"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. override (重写)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#affect-field"><span class="toc-number">5.</span> <span class="toc-text">5. affect field</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#namespace"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. namespace</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#decoration"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1. decoration.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. class</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#memory"><span class="toc-number">6.</span> <span class="toc-text">6. memory</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#allocation"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. allocation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#allocation-ways"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1. allocation ways</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-like"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2. array like</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-1"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3. class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory-storage"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. memory storage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heap-storage"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. heap storage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#segment-fault"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. segment fault</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-2019-11-19-C-1" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      C++
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2019/11/19/2019-11-19-C-1/" class="article-date">
	  <time datetime="2019-11-19T04:50:43.000Z" itemprop="datePublished">2019-11-19</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/computer-science/">computer science</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/laungage/" rel="tag">laungage</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2019/11/19/2019-11-19-C-1/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>C++ 基础知识和语法</p>
<a id="more"></a>

<h1 id="Overview">1. Overview</h1><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。对象和变量其实一回事，只不过从不同角度来看。</p>
<ul>
<li><p><strong>数据类型</strong> - 其实不是类，无法继承，没有成员函数，但可以看作最基础的类</p>
</li>
<li><p><strong>类 -</strong> 类可以定义为描述对象行为/状态的模板/蓝图。</p>
</li>
<li><p><strong>对象/变量 -</strong> 对象当作类的实体化；变量是一样的，只不过变量强调的是内存的分配。</p>
</li>
</ul>
<ul>
<li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li>
</ul>
<h1 id="Variable">2. Variable</h1><h2 id="data-type">2.1. data type</h2><h3 id="basic-type">2.1.1. basic type</h3><ul>
<li><p><strong>Def</strong></p>
<ul>
<li>basic type可以看作最弱的类</li>
<li>basic type 和 class 的区别<ul>
<li>The basic types can’t have members. Classes can (and usually will).</li>
<li>The basic types can’t be specified as a base-class.</li>
</ul>
</li>
</ul>
</li>
<li><p>c++ basic data type </p>
<p><img src="2019-11-19-C-1/i1.png" alt="i1"></p>
</li>
<li><p>init </p>
<p>normal </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b; <span class="comment">//变量声明，编译时有用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> b=<span class="number">10</span>;<span class="comment">//变量定义</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>new</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	2、直接初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="title">j</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>




</li>
</ul>
<h3 id="const-decoration">2.1.2. const decoration</h3><ul>
<li><p><strong>Def</strong> </p>
<p>宏定义常量跟const常量的区别: 宏定义编译器不会检查语法错误，而const则会检查语法问题</p>
</li>
<li><p>const int a</p>
<p>const修饰基本变量 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>; <span class="comment">// x的值不能再被改变</span></span><br></pre></td></tr></table></figure>

<p>用可变的*y去操作不可变的x，权限大-权限小 编译器出错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *y = &amp;x;</span><br></pre></td></tr></table></figure>







</li>
</ul>
<ul>
<li><p>const int *p = x</p>
<p>const修饰*p, *p的值不能赋值，p可以赋值。</p>
<p>或者等价写法：</p>
<figure class="highlight plain"><figcaption><span>const *p </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int const *p = NULL;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>const int &amp;p = x</p>
<p>此时修饰的是引用y，y不能再赋值，x可以赋值</p>
<pre><code>int x = 3;
const int &amp;y = x;</code></pre><p>被const修饰过的形参a和b不能改变其值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void fun(const int &amp;a,const int &amp;b)&#123;</span><br><span class="line">	// 被const修饰过的形参a和b不能改变其值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="const-class">2.1.2.1. const class</h4><ul>
<li><p><strong>Def</strong>: const object </p>
<ul>
<li><p><strong>Qua</strong>: </p>
<p>在定义对象时必须进行初始化; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int a = 1;</span><br></pre></td></tr></table></figure>

<p>const 对象 or 成员变量是const，要求成员变量必须有初始值，因为事后无法赋值</p>
<p>只能调用它的常成员函数，而不能调用普通的成员函数。常成员函数是常对象的唯一的对外接口。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Def</strong>: const member </p>
<ul>
<li><strong>Qua</strong>:<br>构造函数就只能通过初始化列表对该数据成员进行初始化，而任何其他的函数都不能对该成员函数赋值。</li>
</ul>
</li>
<li><p><strong>Def</strong>: const member function</p>
<ul>
<li><p><strong>Qua</strong>: </p>
<p>const是函数类型的组成部分，所以在函数的实现部分也要带关键字const。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void showDate() const;       // 声明</span><br><span class="line">void showDate() const       // 实现</span><br><span class="line">&#123;</span><br><span class="line">    printf(“year”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常成员函数不能更新对象的数据成员，也不能调用该类中的普通成员函数，这就保证了在常成员函数中绝对不会更新数据成员的值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="auto">2.1.2.2. auto</h4><ul>
<li><p>init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f1=3.14; //自动推导类型，在C++11中已删除这一用法</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="register">2.1.2.3. register</h4><ul>
<li><p><strong>Def</strong> </p>
<p>register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘&amp;’ 运算符（因为它没有内存位置）。    </p>
</li>
</ul>
<h4 id="static">2.1.2.4. static</h4><ul>
<li><p><strong>Def</strong> </p>
<p>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。</p>
</li>
</ul>
<ul>
<li><p>example </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">extern void fun();</span><br><span class="line">int num=10;</span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">    while (num&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        fun();</span><br><span class="line">        num--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fun()&#123;</span><br><span class="line">    static int index=5; //程序的生命周期内保持局部变量的存在</span><br><span class="line">    index++;</span><br><span class="line">    cout&lt;&lt;&quot;index=&quot;&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&quot;count=&quot;&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">index=6</span><br><span class="line">count=10</span><br><span class="line">index=7</span><br><span class="line">count=9</span><br><span class="line">index=8</span><br><span class="line">count=8</span><br><span class="line">index=9</span><br><span class="line">count=7</span><br><span class="line">index=10</span><br><span class="line">count=6</span><br><span class="line">index=11</span><br><span class="line">count=5</span><br><span class="line">index=12</span><br><span class="line">count=4</span><br><span class="line">index=13</span><br><span class="line">count=3</span><br><span class="line">index=14</span><br><span class="line">count=2</span><br><span class="line">index=15</span><br><span class="line">count=1</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="extern">2.1.2.5. extern</h4><ul>
<li><p><strong>Def</strong></p>
<p>extern 是程序使用未定义的变量或者方法来通过编译，链接程序的时候再将变量的定义和方法的定义链接过来。</p>
</li>
</ul>
<h4 id="mutable">2.1.2.6. mutable</h4><ul>
<li><p><strong>Def</strong></p>
<p>仅适用于类对象</p>
</li>
</ul>
<h4 id="thread-local">2.1.2.7. thread_local</h4><ul>
<li><p><strong>Def</strong></p>
<p>使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。</p>
</li>
</ul>
<h3 id="reference-decoration">2.1.3. reference decoration</h3><h4 id="reference-of-variable-int-amp-xxx">2.1.3.1. reference of variable   (int &amp;xxx)</h4><ul>
<li><p>init </p>
<p>int &amp;b = a; //必须要初始化引用</p>
</li>
<li><p>example  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 用C++引用交换两个数</span><br><span class="line">void fun(int &amp;a, int &amp;b) &#123;</span><br><span class="line">	int c = 0;</span><br><span class="line">	c = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h4 id="reference-of-pointer-int-amp-xxx">2.1.3.2. reference of pointer (int* &amp; xxx)</h4><ul>
<li><p><strong>Def</strong></p>
<p>see int* as whole, meaning the reference of pointer variable</p>
</li>
<li><p>example </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//	3、指针类型的引用</span><br><span class="line">//	类型  *&amp;指针引用名  = 指针变量</span><br><span class="line">int x = 10;</span><br><span class="line">int *p = &amp;x; //必须要初始化引用</span><br><span class="line">int *&amp;q = p; // 这边赋值的仍然是一个地址，即是q是一个地址</span><br><span class="line">*q = 20;</span><br><span class="line">cout &lt;&lt; &quot;q = &quot; &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">*p = 30;</span><br><span class="line">cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; endl; // p代表的是地址</span><br><span class="line">cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl; // *p代表的是指向这个内存地址的值</span><br><span class="line"></span><br><span class="line">int v = 15, f = 10;</span><br><span class="line">fun(&amp;v, &amp;f);</span><br><span class="line">cout &lt;&lt; &quot;v = &quot; &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;f = &quot; &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">fun(v, f);</span><br><span class="line">cout &lt;&lt; &quot;v = &quot; &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;f = &quot; &lt;&lt; f &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">fun1(v, f);</span><br><span class="line">cout &lt;&lt; &quot;v = &quot; &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;f = &quot; &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="pointer-decoration">2.1.4. pointer decoration</h3><h4 id="pointer-of-varibale">2.1.4.1. pointer of varibale</h4><ul>
<li><p>init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 用指针交换两个数</span><br><span class="line">void fun(int *a, int *b) &#123;</span><br><span class="line">	int c = 0;</span><br><span class="line">	c = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="array-of-pointer-指针数组）">2.1.4.2. array of pointer (指针数组）</h4><ul>
<li><p><strong>Def</strong></p>
<p>a array of pointer, every element is a pointer. basically is an array.</p>
</li>
<li><p>init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char * n [3]=&#123;&quot;gain&quot;,&quot;much&quot;,&quot;strong&quot;&#125;; // 不加括号就是指针数组</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>![image-20191118121403216](/Users/huangbenson/Library/Application Support/typora-user-images/image-20191118121403216.png)</p>
<h4 id="pointer-of-array（数组指针）">2.1.4.3. pointer of array（数组指针）</h4><ul>
<li><p><strong>Def</strong> </p>
<p>pointer points to array. basically is a pointer </p>
</li>
<li><p>init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char (*p) [4];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c[] [4] = &#123;&quot;哥&quot;, &quot;哥&quot;, &quot;我&quot;, &quot;岸&quot;, &quot;上&quot;, &quot;走&quot;&#125;;    //UTF－8：一个汉字=3个字节</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int *a = new int[10]; // 申请10个int的空间，返回指向第一个int的指针。所以它其实不是数组指针，数组指针指向一个数组，他指向数组的第一个数。</span><br></pre></td></tr></table></figure>
</li>
<li><p>opertation</p>
<ul>
<li>指针+1，是+指针类型对应字节数；指针的地址+1，是+8****</li>
</ul>
</li>
</ul>
<h3 id="array-decoration">2.1.5. array decoration</h3><ul>
<li><p><strong>Def</strong> </p>
<p><strong>Def</strong>ina a array of elements</p>
</li>
<li><p>qua <strong>指针和数组并不是相等的，</strong></p>
<ul>
<li><strong>当声明一个数组时，它同时也分配了一段内存空间，用于存储数组元素，但当声明一个指针时，它只分配了用于容纳指针的空间（32位中4个字节的大小）。</strong></li>
<li>数组和指针都指向内存首地址，但数组是常量，指针是变量。（而char * p = “Hello World”的意义是在栈上创建指针，指向存储在静态数据区的字符串，指针p是一个指针变量，<strong>p++操作是正确的</strong>。）</li>
</ul>
</li>
<li><p>operation</p>
<ul>
<li><strong><em>\</em>数组名+1，是+数组元素大小的字节数；\</strong>*<em>数组名的地址+1，是+整个数组大小的字节数***</em></li>
</ul>
</li>
</ul>
<h3 id="enum-type">2.1.6. enum type</h3><ul>
<li><p>init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">enum color</span><br><span class="line">&#123;</span><br><span class="line">    blue,</span><br><span class="line">    red,</span><br><span class="line">    white</span><br><span class="line">&#125;; //默认值从0开始</span><br><span class="line">int main()&#123;</span><br><span class="line">    color c=red;</span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="string-type">2.1.7. string type</h3><ul>
<li><p>init</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">"liugx"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">age</span><span class="params">(<span class="string">"27"</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(name)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="number">5</span>,<span class="string">'c'</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>functions</p>
</li>
</ul>
<h3 id="vector-type">2.1.8. vector type</h3><ul>
<li><p>init </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>); <span class="comment">//定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。</span></span><br><span class="line">（<span class="number">2</span>）<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line">（<span class="number">3</span>）<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b); <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line">（<span class="number">4</span>）<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b.<span class="built_in">begin</span>(),b.<span class="built_in">begin</span>+<span class="number">3</span>); <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line">（<span class="number">5</span>）<span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(b,b+<span class="number">7</span>); <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>function </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）a.assign(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">（<span class="number">2</span>）a.assign(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">（<span class="number">3</span>）a.back(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">（<span class="number">4</span>）a.front(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">（<span class="number">5</span>）a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">（<span class="number">6</span>）a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">（<span class="number">7</span>）a.empty(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">（<span class="number">8</span>）a.pop_back(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">（<span class="number">9</span>）a.erase(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）</span></span><br><span class="line">（<span class="number">10</span>）a.push_back(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">（<span class="number">11</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">（<span class="number">12</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">（<span class="number">13</span>）a.insert(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">（<span class="number">14</span>）a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">（<span class="number">15</span>）a.capacity(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">（<span class="number">16</span>）a.resize(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">（<span class="number">17</span>）a.resize(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">（<span class="number">18</span>）a.reserve(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">（<span class="number">19</span>）a.swap(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">（<span class="number">20</span>）a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>operation </p>
<ul>
<li><p>append</p>
<p>from int </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 vector&lt;int&gt; a;</span><br><span class="line">2 for(int i=0;i&lt;10;i++)</span><br><span class="line">3 a.push_back(i);</span><br></pre></td></tr></table></figure>

<p>from array</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a[6]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt; b；</span><br><span class="line">for(int i=1;i&lt;=4;i++)</span><br><span class="line">b.push_back(a[i]);</span><br></pre></td></tr></table></figure>

<p>from vector </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[6]=&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">vector&lt;int&gt; b;</span><br><span class="line">vector&lt;int&gt; c(a,a+4);</span><br><span class="line">for(vector&lt;int&gt;::iterator it=c.begin();it&lt;c.end();it++)</span><br><span class="line">b.push_back(*it);</span><br></pre></td></tr></table></figure>

<p>from txt </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream in(&quot;data.txt&quot;);</span><br><span class="line">vector&lt;int&gt; a;</span><br><span class="line">for(int i; in&gt;&gt;i)</span><br><span class="line">    a.push_back(i);</span><br></pre></td></tr></table></figure>

<p>mistake: do not assign vector without init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; a;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>sorting</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）sort(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span><br><span class="line">（2）reverse(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span><br><span class="line">（3）copy(a.begin(),a.end(),b.begin()+1); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span><br><span class="line">（4）find(a.begin(),a.end(),10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="Class">3. Class</h1><h2 id="compiling-sequence">3.1. compiling sequence</h2><ul>
<li><p>compiling sequence: </p>
<p>按代码从上到下</p>
<ul>
<li>编译变量(variable)</li>
<li>类型别名(type<strong>Def</strong>, using)</li>
<li>函数声明,返回值和形参；</li>
</ul>
<p>最后</p>
<ul>
<li>再编译成员函数的函数体。</li>
</ul>
</li>
<li><p>note: </p>
<p>这也就解释了为什么成员函数可以访问成员变量，即使这个变量是放在类的最末尾(后于这个成员函数定义)。原因就是编译器先编译整个类(除成员函数的函数体)，然后再编译成员函数体。</p>
<p>这还解释了为什么在类中重命名一些类型尽量放到类的最开始处。因为类中的除成员函数体之外都是顺序编译的，如果不把类型重命名放到使用该重命名的类型之前，那么编译器就不会认识这个重命名的类型。</p>
</li>
</ul>
<h3 id="construction-function">3.1.1. construction function</h3><ul>
<li><p><strong>Def</strong> </p>
<p>就是在声明对象的时候可以直接赋值给该对象私有成员，不用去调用接口赋值，方便一点，这个直接赋值呢，又分为在构造函数内部（函数实现部分，大括号内）对每个私有数据成员赋值，还可以用列表初始化的方式赋值（这点比较重要，在继承的时候还会再拓展的），书上例子都有，我在这说的意思就是你自己好好去看看书上的例题代码。</p>
</li>
</ul>
<h3 id="destruction-function">3.1.2. destruction function</h3><ul>
<li><p><strong>Def</strong> </p>
<p>在该类的对象的生命周期结束时调用，只要是用于若构造函数声明了内存空间的话，释放掉，析构函数的调用次序是对象的声明顺序的逆序，因为这些对象存入的地方是栈，栈具有先进后出的特点</p>
</li>
</ul>
<h3 id="static-function">3.1.3. static function</h3><ul>
<li><p><strong>Qua</strong></p>
<ul>
<li><p>只有一种初始化方式，在类外初始化；</p>
</li>
<li><p>静态成员函数只允许访问静态成员函数或是静态数据成员，而普通函数可以随便访问；</p>
</li>
</ul>
</li>
</ul>
<p>###suspend pointer</p>
<ul>
<li><p><strong>Def</strong> </p>
<p>第一个对象的私有成员指针指向了这块内存区域，然后将该对象赋值给第二个对象，执行第二个函数的析构函数时，第一个对象的指针本来指向该内存区域，但是被释放了，就会变成一个野指针，擅自修改或调用就会出现未知bug，这就是指针悬挂问题，所以需要重载拷贝构造函数以及重载赋值运算符，在赋值的时候给第二个对象也开辟一块新的内存空间将字符串复制过去（关于如何重载，书上有例子）</p>
</li>
</ul>
<h1 id="Function">4. Function</h1><h2 id="function-type">4.1. function type</h2><h3 id="basic-type-1">4.1.1. basic type</h3><ul>
<li><p>init </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int function (x, y);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="inline-decoration">4.1.2. inline decoration</h3><ul>
<li><p><strong>Def</strong></p>
<p>replace function with codes</p>
</li>
<li><p><strong>Qua</strong>: </p>
<ul>
<li>pro： 内联函数编译器处理时相当于只调用方法体里面的逻辑，好处省时，适用于循环调用该函数时用</li>
<li>con：为什么不把所有函数都写成内联函数？<ul>
<li>1、内联编译时建议性的，由编译器决定</li>
<li>2、逻辑简单，调用频繁的函数建议使用内联</li>
<li>3、递归函数无法使用内联方式，编译器会把递归函数当成普通函数处理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="declaration">4.2. declaration</h2><ul>
<li><p><strong>Def</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void fun(int i, int k = 5, int j = 10);</span><br><span class="line"> //void fun(int i,int k = 5, int j);// 编译出错</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="Definition">4.3. Definition</h2><ul>
<li><p><strong>Def</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	void fun(int i, int k, int j) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; k &lt;&lt; j &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="overload-重载">4.4. overload(重载)</h2><ul>
<li><p><strong>Def</strong> </p>
<p>在相同作用域内，函数名称相同，参数个数，参数类型或者返回值不同的称之为函数重载</p>
</li>
<li><p>example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int getMax(int i, int j) &#123;</span><br><span class="line">	// to do</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float getMax(float i, float j) &#123;</span><br><span class="line">	// to do</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double getMax(double i, double j) &#123;</span><br><span class="line">	// to do</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="override-重写">4.5. override (重写)</h2><ul>
<li><strong>Def</strong> </li>
</ul>
<h1 id="affect-field">5. affect field</h1><p>##affect field </p>
<ul>
<li><p><strong>Def</strong> </p>
<p>命名空间是ANSIC++引入的可以由用户命名的作用域，用来处理程序中 常见的同名冲突。<br>在 C语言中定义了3个层次的作用域，即</p>
<ul>
<li><p>文件，编译单元</p>
<ul>
<li><p>单个文件（static）</p>
</li>
<li><p>所有文件，整个程序（global）</p>
<p>但是，如果一个程序包括文件A和文件B，那么在进行连接时，会报告出错，因为在同一个程序中有两个同名的变量，认为是对变量的重复定义。可 以通过extern声明同一程序中的两个文件中的同名变量是同一个变量。如果在文件B中有以下声明：<br>extem int a；</p>
</li>
</ul>
</li>
<li><p>命名空间</p>
</li>
<li><p>C++又引入了类作用域，类是出现在文件内的。</p>
</li>
<li><p>函数（函数内）</p>
</li>
<li><p>复合语句（语句内）</p>
</li>
</ul>
<p>在不同的作用域中可以定义相同名字的变量，互不于扰，系统能够区别它们。</p>
</li>
</ul>
<h2 id="namespace">5.1. namespace</h2><ul>
<li><p><strong>Def</strong> </p>
<p>实际上就是一个由程序设计者命名的内存区域，程序设计者可以根据需要指定一些有名字的空间域，把一些全局实分别放在各个命名空间中，从而与其他全局实体分隔开来。</p>
</li>
<li><p>qua</p>
<p>建立一些互相分隔的作用域，把一些全局实体分隔开来。</p>
</li>
<li><p>example </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">namespace myNameSpace &#123;</span><br><span class="line">int A;</span><br><span class="line"></span><br><span class="line">class Liu&#123;</span><br><span class="line">public:</span><br><span class="line">	void setA()&#123;</span><br><span class="line">		A = 20;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void print()&#123;</span><br><span class="line">	cout &lt;&lt; &quot;A ：&quot; &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getMax(int num) &#123;</span><br><span class="line">	return num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using namespace myNameSpace;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	myNameSpace::A = 10;</span><br><span class="line">	myNameSpace::print();</span><br><span class="line">	myNameSpace::Liu liu;</span><br><span class="line">	liu.setA();</span><br><span class="line">	print();</span><br><span class="line">	std::cout &lt;&lt; &quot;命名空间的使用：&quot; &lt;&lt; myNameSpace::getMax(9) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="decoration">5.1.1. decoration.</h3><ul>
<li><p><strong>Def</strong> </p>
<ul>
<li><p>1.显式，在某某命名空间中</p>
</li>
<li><p>2.全局命名空间，等同于全局空间。</p>
</li>
<li><p>3.匿名命名空间   例：namespace{   class A；  }</p>
</li>
</ul>
</li>
</ul>
<p>​                         </p>
<h2 id="class">5.2. class</h2><p>类中的数据和函数分为公有类（public），保护类（protected），私有类（private），</p>
<p>类公有派生类，保护派生类，私有派生类</p>
<p>类中的成员 在public中 ，可以在其他地方直接使用  使用方法：对象.公用类成员（对象：：公用类成员）</p>
<p>而其他的需要借助公有类函数调用 ，但是在类中可以直接调用 。</p>
<p>例： class x的对象X的成员m具有类作用域，对m的访问有三种</p>
<p>（1）如果 在X的成员函数中没有声明 同名 的局部作用域标识符，那么可以在该函数内可以直接访问成员m。</p>
<p>（2）通过表达式x.m或者x::m。这正是程序中访问对象的最基本的方法</p>
<p>（3）通过ptr-&gt;m这样的表达式，其中ptr为指向x类的一个对象的指针。</p>
<h1 id="memory">6. memory</h1><h2 id="allocation">6.1. allocation</h2><h3 id="allocation-ways">6.1.1. allocation ways</h3><ul>
<li><p><strong>Def</strong> </p>
<p>1． 从静态存储区分配：此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储。<br>2． 在stack区分配：相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈<a href="https://www.baidu.com/s?wd=内存分配&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">内存分配</a>运算内置于处理器的指令集中，效率高，但容量有限。<br>3． 在heap区分配：<a href="https://www.baidu.com/s?wd=动态分配内存&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">动态分配内存</a>。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题。</p>
</li>
</ul>
<h3 id="array-like">6.1.2. array like</h3><ul>
<li><p>c based </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char a []= &#123;sa,a,a&#125;;</span><br></pre></td></tr></table></figure>

<p>in stack </p>
</li>
<li><p>string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string a ;</span><br></pre></td></tr></table></figure>

<p>in stack and heap</p>
</li>
<li><p>vector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Type&gt; vect;</span><br></pre></td></tr></table></figure>

<p>will allocate the <code>vector</code>, i.e. the header info, on the stack, but the elements on heap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Type&gt; *vect = new vector&lt;Type&gt;;</span><br></pre></td></tr></table></figure>

<p>allocates everything on the heap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Type*&gt; vect;</span><br></pre></td></tr></table></figure>

<p>will allocate the <code>vector</code> on the stack and a bunch of pointers on the free store, but where these point is determined by how you use them (you could point element 0 to the free store and element 1 to the stack, say).</p>
</li>
</ul>
<h3 id="class-1">6.1.3. class</h3><h2 id="memory-storage">6.2. memory storage</h2><p>![image-20191118120622678](/Users/huangbenson/Library/Application Support/typora-user-images/image-20191118120622678.png)</p>
<ul>
<li><strong>Def</strong> <ul>
<li>栈区 int i = 1;定义一个变量</li>
<li>堆区    int *p = new int[10];</li>
<li>全局区    存储的全局变量和静态变量</li>
<li>常量区    string str = “c++”</li>
<li>代码区    存储逻辑代码的二进制</li>
</ul>
</li>
</ul>
<h2 id="heap-storage">6.3. heap storage</h2><ul>
<li><p>example in c </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 	C语言内存申请和释放</span><br><span class="line">	 * 	void *malloc(size_t size)</span><br><span class="line">	 * 	void free(void *memblock)</span><br><span class="line">	 */</span><br></pre></td></tr></table></figure>
</li>
<li><p>example1 in c++</p>
<pre><code>/**
 * C++中内存申请和释放使用关键字new和delete，需要配套使用
 */
//申请
int *p = new int(10); 初始化指针，分配一块4的内存，初始化值为10
if (NULL == p) {
    system(&quot;pause&quot;);
    return 0;
}
//释放
delete p;
p = NULL;

//如何申请和释放内存块？
int *arr = new int[1000]; 创建一个10个大小的int指针数组。
//假设内存申请失败
if (NULL == arr) {
    system(&quot;pause&quot;);
    return 0;
}
delete[] arr;//如果不加[]，则只会释放arr[0]的内存
arr = NULL;

cout &lt;&lt; &quot;C++内存管理&quot; &lt;&lt; endl;
return 0;}</code></pre></li>
<li><p>example2 in c++ </p>
<pre><code>using namespace std;

class Tv {
public:
    int x = 10;
    int y = 20;
    void px() {
        cout &lt;&lt; x &lt;&lt; endl;
    }
    void py() {
        cout &lt;&lt; y &lt;&lt; endl;
    }
};

int main() {
    Tv tv;
cout &lt;&lt; tv.x &lt;&lt; endl; //在内存开辟一块栈空间，不需要主动释放
tv.px();
tv.py();
//    Tv *tvNew;
Tv *tvNew = new Tv(); // 向内存申请一块堆空间
if (NULL == tvNew) {
system(&quot;pause&quot;);
return 0;
}
// 类似于C语言的写法
cout &lt;&lt; (*tvNew).x &lt;&lt; endl;
(*tvNew).px();
(*tvNew).py();
// 类似于NDK编程的写法
cout &lt;&lt; tvNew-&gt;x &lt;&lt; endl;
tvNew-&gt;px();
tvNew-&gt;py();
delete tvNew; // 在内存中申请的堆空间，需要主动释放
tvNew = NULL;
return 0;</code></pre></li>
</ul>
<h2 id="segment-fault">6.4. segment fault</h2><ul>
<li><p><strong>Def</strong> </p>
<p>1． <a href="https://www.baidu.com/s?wd=内存分配&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">内存分配</a>未成功，却被使用。<br>对策：使用内存之前检查是否分配成功。用p!=NULL判断。<br>2． <a href="https://www.baidu.com/s?wd=内存分配&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">内存分配</a>成功，未初始化就被使用。<br>内存的缺省值没有统一的标准。大部分编译器以0作为初始值，但不完全是。<br>对策：内存初始化时赋初值。<br>3． 内存操作越界。<br>对策：只能是小心了。<br>4． 释放了内存，仍然使用。<br>（1） 使用显示delete和free的野指针。<br>对策：释放完内存，将指针置为NULL。<br>（2） 使用隐式delete和free的野指针。主要是指函数返回指向栈内存的指针或引用。<br>对策：当然是不要返回就可以了。<br>5． 未释放内存，导致内存泄露。<br>用new/malloc开辟了内存，没用delete/free释放.<br>对策：new和delete的个数一定相同；malloc和free的个数一定相同；new[]和[]delete一定对应。</p>
</li>
</ul>
<p>}</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://steinsgate9.github.io/2019/11/19/2019-11-19-C-1/" title="C++" target="_blank" rel="external">https://steinsgate9.github.io/2019/11/19/2019-11-19-C-1/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/SteinsGate9" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/SteinsGate9" target="_blank"><span class="text-dark">Benson</span><small class="ml-1x">B.Eng. at ZJU</small></a></h3>
        <div>Live Long, Play Hard.</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NzYxNi8yNDExNA">
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>    
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>





</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/SteinsGate9" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://weibo.com/u/5568381899" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/bensonuouououo" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.linkedin.com/in/shicheng-huang-9a1176177/" target="_blank" title="Linkedin" data-toggle=tooltip data-placement=top><i class="icon icon-linkedin"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
<script defer type="text/javascript">
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];

    if (typeof LivereTower === 'function') { return; }

    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;

    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>








</body>
</html>